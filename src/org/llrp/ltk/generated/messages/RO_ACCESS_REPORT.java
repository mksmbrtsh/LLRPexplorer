/*
*
* This file was generated by LLRP Code Generator
* see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
* for more information
* Generated on: Sun Apr 08 14:14:10 EDT 2012;
*
*/

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.messages;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.generated.parameters.RFSurveyReportData;
import org.llrp.ltk.generated.parameters.TagReportData;
import org.llrp.ltk.types.BitList;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.UnsignedInteger;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This message is issued by the Reader to the Client, and it contains the results of the RO and Access operations. The ROReportSpec and AccessReportSpec parameters define the contents and triggers for this message.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=77&view=fit">LLRP Specification Section 13.1.2</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=125&view=fit">LLRP Specification Section 16.1.30</a>}


 */
public class RO_ACCESS_REPORT extends LLRPMessage {
    public static final SignedShort TYPENUM = new SignedShort(61);
    private static final Logger LOGGER = Logger.getLogger(RO_ACCESS_REPORT.class);
    public static final String RESPONSETYPE = "";
    protected List<TagReportData> tagReportDataList = new LinkedList<TagReportData>();
    protected List<RFSurveyReportData> rFSurveyReportDataList = new LinkedList<RFSurveyReportData>();
    protected List<Custom> customList = new LinkedList<Custom>();

    /**
     * empty constructor to create new message
     * with LLRP version set to 1.0 (0x1).
     */
    public RO_ACCESS_REPORT() {
        setVersion(new BitList(0, 0, 1));
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param list to be decoded
     */
    public RO_ACCESS_REPORT(final LLRPBitList list)
        throws InvalidLLRPMessageException {
        decodeBinary(list.toByteArray());
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param byteArray representing message
     */
    public RO_ACCESS_REPORT(final byte[] byteArray)
        throws InvalidLLRPMessageException {
        decodeBinary(byteArray);
    }

    /**
    * Constructor to create message from xml encoded message
    * calls decodeXML to decode message.
    * @param document to be decoded
    */
    public RO_ACCESS_REPORT(final Document document)
        throws InvalidLLRPMessageException {
        decodeXML(document);
    }

    /**
    * {@inheritDoc}
    */
    protected LLRPBitList encodeBinarySpecific()
        throws InvalidLLRPMessageException {
        LLRPBitList resultBits = new LLRPBitList();

        if (tagReportDataList == null) {
            //just warn - it is optional 
            LOGGER.info(" tagReportDataList not set");
        } else {
            for (TagReportData field : tagReportDataList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (rFSurveyReportDataList == null) {
            //just warn - it is optional 
            LOGGER.info(" rFSurveyReportDataList not set");
        } else {
            for (RFSurveyReportData field : rFSurveyReportDataList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (customList == null) {
            //just warn - it is optional 
            LOGGER.info(" customList not set");
        } else {
            for (Custom field : customList) {
                resultBits.append(field.encodeBinary());
            }
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Document encodeXML() throws InvalidLLRPMessageException {
        try {
            Namespace ns = Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE);

            Element root = new Element("RO_ACCESS_REPORT", ns);
            //	Element root = new Element("RO_ACCESS_REPORT");
            root.addNamespaceDeclaration(Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE));

            if (version == null) {
                throw new InvalidLLRPMessageException("Version not set");
            } else {
                root.setAttribute("Version", version.toInteger().toString());
            }

            if (messageID == null) {
                throw new InvalidLLRPMessageException("MessageID not set");
            } else {
                root.setAttribute("MessageID", messageID.toString(10));
            }

            //parameters
            if (tagReportDataList == null) {
                LOGGER.info("tagReportDataList not set");
            } else {
                for (TagReportData field : tagReportDataList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            if (rFSurveyReportDataList == null) {
                LOGGER.info("rFSurveyReportDataList not set");
            } else {
                for (RFSurveyReportData field : rFSurveyReportDataList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            if (customList == null) {
                LOGGER.info("customList not set");
            } else {
                for (Custom field : customList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            Document doc = new Document(root);

            if (isValidXMLMessage(doc, LLRPConstants.LLRPMESSAGESCHEMAPATH)) {
                return doc;
            } else {
                return null;
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary)
        throws InvalidLLRPMessageException {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;

        // list of parameters
        tagReportDataList = new LinkedList<TagReportData>();
        LOGGER.debug("decoding parameter tagReportDataList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(TagReportData.TYPENUM)) {
                //if first bit is 1 it is a TV Parameter
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = TagReportData.length();
                }

                tagReportDataList.add(new TagReportData(binary.subList(
                            position, tempLength)));
                LOGGER.debug("adding TagReportData to tagReportDataList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (tagReportDataList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional tagReportDataList");
        }

        // list of parameters
        rFSurveyReportDataList = new LinkedList<RFSurveyReportData>();
        LOGGER.debug("decoding parameter rFSurveyReportDataList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(RFSurveyReportData.TYPENUM)) {
                //if first bit is 1 it is a TV Parameter
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = RFSurveyReportData.length();
                }

                rFSurveyReportDataList.add(new RFSurveyReportData(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding RFSurveyReportData to rFSurveyReportDataList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (rFSurveyReportDataList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional rFSurveyReportDataList");
        }

        // list of parameters
        customList = new LinkedList<Custom>();
        LOGGER.debug("decoding parameter customList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                //allowed custom parameters for this parameter	
                //end allowed parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                customList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (customList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional customList");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(final Document document)
        throws InvalidLLRPMessageException {
        Element temp = null;
        Custom custom;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        try {
            isValidXMLMessage(document, LLRPConstants.LLRPMESSAGESCHEMAPATH);

            Element root = (Element) document.getRootElement().clone();
            List<Element> tempList = null;

            // the version field is always 3 bit long 
            // if the version attribute is not set in the LTK-XML message,
            // it is set to version 001
            String versionAttribute = root.getAttributeValue("Version");

            if (versionAttribute != null) {
                version = new BitList(3);
                version.setValue(new Integer(versionAttribute));
            } else {
                version = new BitList(0, 0, 1);
            }

            messageID = new UnsignedInteger(root.getAttributeValue("MessageID"));

            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            tagReportDataList = new LinkedList<TagReportData>();
            tempList = root.getChildren("TagReportData", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "RO_ACCESS_REPORT misses optional parameter of type tagReportDataList");
            } else {
                for (Element e : tempList) {
                    tagReportDataList.add(new TagReportData(e));
                    LOGGER.debug("adding TagReportData to tagReportDataList ");
                }
            }

            root.removeChildren("TagReportData", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            rFSurveyReportDataList = new LinkedList<RFSurveyReportData>();
            tempList = root.getChildren("RFSurveyReportData", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "RO_ACCESS_REPORT misses optional parameter of type rFSurveyReportDataList");
            } else {
                for (Element e : tempList) {
                    rFSurveyReportDataList.add(new RFSurveyReportData(e));
                    LOGGER.debug(
                        "adding RFSurveyReportData to rFSurveyReportDataList ");
                }
            }

            root.removeChildren("RFSurveyReportData", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            customList = new LinkedList<Custom>();
            tempList = root.getChildren("Custom", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "RO_ACCESS_REPORT misses optional parameter of type customList");
            } else {
                for (Element e : tempList) {
                    customList.add(new Custom(e));
                    LOGGER.debug("adding Custom to customList ");
                }
            }

            root.removeChildren("Custom", ns);

            //custom parameter
            //end custom
            if (root.getChildren().size() > 0) {
                String message = "RO_ACCESS_REPORT has unknown element " +
                    ((Element) root.getChildren().get(0)).getName();
                throw new InvalidLLRPMessageException(message);
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    //setters

    /**
    * set tagReportDataList of type  List &lt;TagReportData>.
    * @param  tagReportDataList to be set
    */
    public void setTagReportDataList(
        final List<TagReportData> tagReportDataList) {
        this.tagReportDataList = tagReportDataList;
    }

    /**
    * set rFSurveyReportDataList of type  List &lt;RFSurveyReportData>.
    * @param  rFSurveyReportDataList to be set
    */
    public void setRFSurveyReportDataList(
        final List<RFSurveyReportData> rFSurveyReportDataList) {
        this.rFSurveyReportDataList = rFSurveyReportDataList;
    }

    /**
    * set customList of type  List &lt;Custom>.
    * @param  customList to be set
    */
    public void setCustomList(final List<Custom> customList) {
        this.customList = customList;
    }

    // end setter

    //getters

    /**
    * get tagReportDataList of type List &lt;TagReportData> .
    * @return  List &lt;TagReportData>
    */
    public List<TagReportData> getTagReportDataList() {
        return tagReportDataList;
    }

    /**
    * get rFSurveyReportDataList of type List &lt;RFSurveyReportData> .
    * @return  List &lt;RFSurveyReportData>
    */
    public List<RFSurveyReportData> getRFSurveyReportDataList() {
        return rFSurveyReportDataList;
    }

    /**
    * get customList of type List &lt;Custom> .
    * @return  List &lt;Custom>
    */
    public List<Custom> getCustomList() {
        return customList;
    }

    // end getters

    //add methods

    /**
    * add element tagReportData of type TagReportData .
    * @param  tagReportData of type TagReportData
    */
    public void addToTagReportDataList(TagReportData tagReportData) {
        if (this.tagReportDataList == null) {
            this.tagReportDataList = new LinkedList<TagReportData>();
        }

        this.tagReportDataList.add(tagReportData);
    }

    /**
    * add element rFSurveyReportData of type RFSurveyReportData .
    * @param  rFSurveyReportData of type RFSurveyReportData
    */
    public void addToRFSurveyReportDataList(
        RFSurveyReportData rFSurveyReportData) {
        if (this.rFSurveyReportDataList == null) {
            this.rFSurveyReportDataList = new LinkedList<RFSurveyReportData>();
        }

        this.rFSurveyReportDataList.add(rFSurveyReportData);
    }

    /**
    * add element custom of type Custom .
    * @param  custom of type Custom
    */
    public void addToCustomList(Custom custom) {
        if (this.customList == null) {
            this.customList = new LinkedList<Custom>();
        }

        this.customList.add(custom);
    }

    // end add
    @Override
    public String getResponseType() {
        return RESPONSETYPE;
    }

    @Override
    public String getName() {
        return "RO_ACCESS_REPORT";
    }

    /**
    * return uniuque type number.
    * @return SignedShort holding unique type number
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }
}
