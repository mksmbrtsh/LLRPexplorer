/*
*
* This file was generated by LLRP Code Generator
* see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
* for more information
* Generated on: Sun Apr 08 14:14:09 EDT 2012;
*
*/

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.messages;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.parameters.AccessReportSpec;
import org.llrp.ltk.generated.parameters.AntennaConfiguration;
import org.llrp.ltk.generated.parameters.AntennaProperties;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.generated.parameters.EventsAndReports;
import org.llrp.ltk.generated.parameters.GPIPortCurrentState;
import org.llrp.ltk.generated.parameters.GPOWriteData;
import org.llrp.ltk.generated.parameters.Identification;
import org.llrp.ltk.generated.parameters.KeepaliveSpec;
import org.llrp.ltk.generated.parameters.LLRPConfigurationStateValue;
import org.llrp.ltk.generated.parameters.LLRPStatus;
import org.llrp.ltk.generated.parameters.ROReportSpec;
import org.llrp.ltk.generated.parameters.ReaderEventNotificationSpec;
import org.llrp.ltk.types.BitList;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.UnsignedInteger;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This is the response by the Reader to the GET_READER_CONFIG message. The response is the LLRPStatus Parameter and the list of configuration parameters based on the RequestedData in GET_READER_CONFIG. If the GET_READER_CONFIG message did not have any errors, the success code is returned in the LLRPStatus parameter, and in addition the requested configuration parameters are returned. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. The response contains at most one instance of each configuration parameter except for two cases, which are as follows:If RequestedData is 0, 2 or 3, and AntennaID is set to 0 in the GET_READER_CONFIG message, the Reader SHALL return one instance of AntennaProperties Parameter or AntennaConfiguration Parameter per requested antenna.If RequestedData is 0 or 9 (10), and GPIPortNum (GPOPortNum) is set to 0 in the GET_READER_CONFIG message, and, if the Reader supports GPI (GPO), the Reader SHALL return one instance of GPIPortCurrentState (GPOWriteData) Parameter per requested GPI Port (GPO Port).


See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=68&view=fit">LLRP Specification Section 12.1.2</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=127&view=fit">LLRP Specification Section 16.1.37</a>}


 */
public class GET_READER_CONFIG_RESPONSE extends LLRPMessage {
    public static final SignedShort TYPENUM = new SignedShort(12);
    private static final Logger LOGGER = Logger.getLogger(GET_READER_CONFIG_RESPONSE.class);
    public static final String RESPONSETYPE = "";
    protected LLRPStatus lLRPStatus;
    protected Identification identification;
    protected List<AntennaProperties> antennaPropertiesList = new LinkedList<AntennaProperties>();
    protected List<AntennaConfiguration> antennaConfigurationList = new LinkedList<AntennaConfiguration>();
    protected ReaderEventNotificationSpec readerEventNotificationSpec;
    protected ROReportSpec rOReportSpec;
    protected AccessReportSpec accessReportSpec;
    protected LLRPConfigurationStateValue lLRPConfigurationStateValue;
    protected KeepaliveSpec keepaliveSpec;
    protected List<GPIPortCurrentState> gPIPortCurrentStateList = new LinkedList<GPIPortCurrentState>();
    protected List<GPOWriteData> gPOWriteDataList = new LinkedList<GPOWriteData>();
    protected EventsAndReports eventsAndReports;
    protected List<Custom> customList = new LinkedList<Custom>();

    /**
     * empty constructor to create new message
     * with LLRP version set to 1.0 (0x1).
     */
    public GET_READER_CONFIG_RESPONSE() {
        setVersion(new BitList(0, 0, 1));
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param list to be decoded
     */
    public GET_READER_CONFIG_RESPONSE(final LLRPBitList list)
        throws InvalidLLRPMessageException {
        decodeBinary(list.toByteArray());
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param byteArray representing message
     */
    public GET_READER_CONFIG_RESPONSE(final byte[] byteArray)
        throws InvalidLLRPMessageException {
        decodeBinary(byteArray);
    }

    /**
    * Constructor to create message from xml encoded message
    * calls decodeXML to decode message.
    * @param document to be decoded
    */
    public GET_READER_CONFIG_RESPONSE(final Document document)
        throws InvalidLLRPMessageException {
        decodeXML(document);
    }

    /**
    * {@inheritDoc}
    */
    protected LLRPBitList encodeBinarySpecific()
        throws InvalidLLRPMessageException {
        LLRPBitList resultBits = new LLRPBitList();

        if (lLRPStatus == null) {
            // single parameter, may not be null
            LOGGER.warn(" lLRPStatus not set");
            throw new InvalidLLRPMessageException(" lLRPStatus not set");
        } else {
            resultBits.append(lLRPStatus.encodeBinary());
        }

        if (identification == null) {
            // optional parameter, may be null
            LOGGER.info(" identification not set");
        } else {
            resultBits.append(identification.encodeBinary());
        }

        if (antennaPropertiesList == null) {
            //just warn - it is optional 
            LOGGER.info(" antennaPropertiesList not set");
        } else {
            for (AntennaProperties field : antennaPropertiesList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (antennaConfigurationList == null) {
            //just warn - it is optional 
            LOGGER.info(" antennaConfigurationList not set");
        } else {
            for (AntennaConfiguration field : antennaConfigurationList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (readerEventNotificationSpec == null) {
            // optional parameter, may be null
            LOGGER.info(" readerEventNotificationSpec not set");
        } else {
            resultBits.append(readerEventNotificationSpec.encodeBinary());
        }

        if (rOReportSpec == null) {
            // optional parameter, may be null
            LOGGER.info(" rOReportSpec not set");
        } else {
            resultBits.append(rOReportSpec.encodeBinary());
        }

        if (accessReportSpec == null) {
            // optional parameter, may be null
            LOGGER.info(" accessReportSpec not set");
        } else {
            resultBits.append(accessReportSpec.encodeBinary());
        }

        if (lLRPConfigurationStateValue == null) {
            // optional parameter, may be null
            LOGGER.info(" lLRPConfigurationStateValue not set");
        } else {
            resultBits.append(lLRPConfigurationStateValue.encodeBinary());
        }

        if (keepaliveSpec == null) {
            // optional parameter, may be null
            LOGGER.info(" keepaliveSpec not set");
        } else {
            resultBits.append(keepaliveSpec.encodeBinary());
        }

        if (gPIPortCurrentStateList == null) {
            //just warn - it is optional 
            LOGGER.info(" gPIPortCurrentStateList not set");
        } else {
            for (GPIPortCurrentState field : gPIPortCurrentStateList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (gPOWriteDataList == null) {
            //just warn - it is optional 
            LOGGER.info(" gPOWriteDataList not set");
        } else {
            for (GPOWriteData field : gPOWriteDataList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (eventsAndReports == null) {
            // optional parameter, may be null
            LOGGER.info(" eventsAndReports not set");
        } else {
            resultBits.append(eventsAndReports.encodeBinary());
        }

        if (customList == null) {
            //just warn - it is optional 
            LOGGER.info(" customList not set");
        } else {
            for (Custom field : customList) {
                resultBits.append(field.encodeBinary());
            }
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Document encodeXML() throws InvalidLLRPMessageException {
        try {
            Namespace ns = Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE);

            Element root = new Element("GET_READER_CONFIG_RESPONSE", ns);
            //	Element root = new Element("GET_READER_CONFIG_RESPONSE");
            root.addNamespaceDeclaration(Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE));

            if (version == null) {
                throw new InvalidLLRPMessageException("Version not set");
            } else {
                root.setAttribute("Version", version.toInteger().toString());
            }

            if (messageID == null) {
                throw new InvalidLLRPMessageException("MessageID not set");
            } else {
                root.setAttribute("MessageID", messageID.toString(10));
            }

            //parameters
            if (lLRPStatus == null) {
                LOGGER.info("lLRPStatus not set");
                throw new MissingParameterException("lLRPStatus not set");
            } else {
                root.addContent(lLRPStatus.encodeXML(lLRPStatus.getClass()
                                                               .getSimpleName(),
                        ns));
            }

            if (identification == null) {
                LOGGER.info("identification not set");
            } else {
                root.addContent(identification.encodeXML(
                        identification.getClass().getSimpleName(), ns));
            }

            if (antennaPropertiesList == null) {
                LOGGER.info("antennaPropertiesList not set");
            } else {
                for (AntennaProperties field : antennaPropertiesList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            if (antennaConfigurationList == null) {
                LOGGER.info("antennaConfigurationList not set");
            } else {
                for (AntennaConfiguration field : antennaConfigurationList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            if (readerEventNotificationSpec == null) {
                LOGGER.info("readerEventNotificationSpec not set");
            } else {
                root.addContent(readerEventNotificationSpec.encodeXML(
                        readerEventNotificationSpec.getClass().getSimpleName(),
                        ns));
            }

            if (rOReportSpec == null) {
                LOGGER.info("rOReportSpec not set");
            } else {
                root.addContent(rOReportSpec.encodeXML(
                        rOReportSpec.getClass().getSimpleName(), ns));
            }

            if (accessReportSpec == null) {
                LOGGER.info("accessReportSpec not set");
            } else {
                root.addContent(accessReportSpec.encodeXML(
                        accessReportSpec.getClass().getSimpleName(), ns));
            }

            if (lLRPConfigurationStateValue == null) {
                LOGGER.info("lLRPConfigurationStateValue not set");
            } else {
                root.addContent(lLRPConfigurationStateValue.encodeXML(
                        lLRPConfigurationStateValue.getClass().getSimpleName(),
                        ns));
            }

            if (keepaliveSpec == null) {
                LOGGER.info("keepaliveSpec not set");
            } else {
                root.addContent(keepaliveSpec.encodeXML(
                        keepaliveSpec.getClass().getSimpleName(), ns));
            }

            if (gPIPortCurrentStateList == null) {
                LOGGER.info("gPIPortCurrentStateList not set");
            } else {
                for (GPIPortCurrentState field : gPIPortCurrentStateList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            if (gPOWriteDataList == null) {
                LOGGER.info("gPOWriteDataList not set");
            } else {
                for (GPOWriteData field : gPOWriteDataList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            if (eventsAndReports == null) {
                LOGGER.info("eventsAndReports not set");
            } else {
                root.addContent(eventsAndReports.encodeXML(
                        eventsAndReports.getClass().getSimpleName(), ns));
            }

            if (customList == null) {
                LOGGER.info("customList not set");
            } else {
                for (Custom field : customList) {
                    root.addContent(field.encodeXML(field.getClass().getName()
                                                         .replaceAll(field.getClass()
                                                                          .getPackage()
                                                                          .getName() +
                                ".", ""), ns));
                }
            }

            Document doc = new Document(root);

            if (isValidXMLMessage(doc, LLRPConstants.LLRPMESSAGESCHEMAPATH)) {
                return doc;
            } else {
                return null;
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary)
        throws InvalidLLRPMessageException {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.warn(
                "GET_READER_CONFIG_RESPONSE misses non optional parameter of type LLRPStatus");
            throw new InvalidLLRPMessageException(
                "GET_READER_CONFIG_RESPONSE misses non optional parameter of type LLRPStatus");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = lLRPStatus.length();
        }

        if ((type != null) && type.equals(LLRPStatus.TYPENUM)) {
            lLRPStatus = new LLRPStatus(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " lLRPStatus is instantiated with LLRPStatus with length" +
                tempLength);
        } else {
            LOGGER.warn(
                "GET_READER_CONFIG_RESPONSE misses non optional parameter of type LLRPStatus");
            throw new InvalidLLRPMessageException(
                "GET_READER_CONFIG_RESPONSE misses non optional parameter of type LLRPStatus");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type Identification");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = identification.length();
        }

        if ((type != null) && type.equals(Identification.TYPENUM)) {
            identification = new Identification(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " identification is instantiated with Identification with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type Identification");
        }

        // list of parameters
        antennaPropertiesList = new LinkedList<AntennaProperties>();
        LOGGER.debug("decoding parameter antennaPropertiesList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(AntennaProperties.TYPENUM)) {
                //if first bit is 1 it is a TV Parameter
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = AntennaProperties.length();
                }

                antennaPropertiesList.add(new AntennaProperties(binary.subList(
                            position, tempLength)));
                LOGGER.debug(
                    "adding AntennaProperties to antennaPropertiesList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (antennaPropertiesList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional antennaPropertiesList");
        }

        // list of parameters
        antennaConfigurationList = new LinkedList<AntennaConfiguration>();
        LOGGER.debug("decoding parameter antennaConfigurationList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(AntennaConfiguration.TYPENUM)) {
                //if first bit is 1 it is a TV Parameter
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = AntennaConfiguration.length();
                }

                antennaConfigurationList.add(new AntennaConfiguration(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding AntennaConfiguration to antennaConfigurationList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (antennaConfigurationList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional antennaConfigurationList");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type ReaderEventNotificationSpec");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = readerEventNotificationSpec.length();
        }

        if ((type != null) && type.equals(ReaderEventNotificationSpec.TYPENUM)) {
            readerEventNotificationSpec = new ReaderEventNotificationSpec(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " readerEventNotificationSpec is instantiated with ReaderEventNotificationSpec with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type ReaderEventNotificationSpec");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type ROReportSpec");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = rOReportSpec.length();
        }

        if ((type != null) && type.equals(ROReportSpec.TYPENUM)) {
            rOReportSpec = new ROReportSpec(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " rOReportSpec is instantiated with ROReportSpec with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type ROReportSpec");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type AccessReportSpec");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = accessReportSpec.length();
        }

        if ((type != null) && type.equals(AccessReportSpec.TYPENUM)) {
            accessReportSpec = new AccessReportSpec(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " accessReportSpec is instantiated with AccessReportSpec with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type AccessReportSpec");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type LLRPConfigurationStateValue");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = lLRPConfigurationStateValue.length();
        }

        if ((type != null) && type.equals(LLRPConfigurationStateValue.TYPENUM)) {
            lLRPConfigurationStateValue = new LLRPConfigurationStateValue(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " lLRPConfigurationStateValue is instantiated with LLRPConfigurationStateValue with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type LLRPConfigurationStateValue");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type KeepaliveSpec");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = keepaliveSpec.length();
        }

        if ((type != null) && type.equals(KeepaliveSpec.TYPENUM)) {
            keepaliveSpec = new KeepaliveSpec(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " keepaliveSpec is instantiated with KeepaliveSpec with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type KeepaliveSpec");
        }

        // list of parameters
        gPIPortCurrentStateList = new LinkedList<GPIPortCurrentState>();
        LOGGER.debug("decoding parameter gPIPortCurrentStateList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(GPIPortCurrentState.TYPENUM)) {
                //if first bit is 1 it is a TV Parameter
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = GPIPortCurrentState.length();
                }

                gPIPortCurrentStateList.add(new GPIPortCurrentState(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding GPIPortCurrentState to gPIPortCurrentStateList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (gPIPortCurrentStateList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional gPIPortCurrentStateList");
        }

        // list of parameters
        gPOWriteDataList = new LinkedList<GPOWriteData>();
        LOGGER.debug("decoding parameter gPOWriteDataList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(GPOWriteData.TYPENUM)) {
                //if first bit is 1 it is a TV Parameter
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = GPOWriteData.length();
                }

                gPOWriteDataList.add(new GPOWriteData(binary.subList(position,
                            tempLength)));
                LOGGER.debug("adding GPOWriteData to gPOWriteDataList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (gPOWriteDataList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional gPOWriteDataList");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type EventsAndReports");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = eventsAndReports.length();
        }

        if ((type != null) && type.equals(EventsAndReports.TYPENUM)) {
            eventsAndReports = new EventsAndReports(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " eventsAndReports is instantiated with EventsAndReports with length" +
                tempLength);
        } else {
            LOGGER.info(
                "GET_READER_CONFIG_RESPONSE misses optional parameter of type EventsAndReports");
        }

        // list of parameters
        customList = new LinkedList<Custom>();
        LOGGER.debug("decoding parameter customList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                //allowed custom parameters for this parameter	
                //end allowed parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                customList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (customList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional customList");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(final Document document)
        throws InvalidLLRPMessageException {
        Element temp = null;
        Custom custom;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        try {
            isValidXMLMessage(document, LLRPConstants.LLRPMESSAGESCHEMAPATH);

            Element root = (Element) document.getRootElement().clone();
            List<Element> tempList = null;

            // the version field is always 3 bit long 
            // if the version attribute is not set in the LTK-XML message,
            // it is set to version 001
            String versionAttribute = root.getAttributeValue("Version");

            if (versionAttribute != null) {
                version = new BitList(3);
                version.setValue(new Integer(versionAttribute));
            } else {
                version = new BitList(0, 0, 1);
            }

            messageID = new UnsignedInteger(root.getAttributeValue("MessageID"));

            //parameter - not choices - no special actions needed
            temp = root.getChild("LLRPStatus", ns);

            if (temp != null) {
                lLRPStatus = new LLRPStatus(temp);
                LOGGER.info(
                    "setting parameter lLRPStatus for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.warn(
                    "GET_READER_CONFIG_RESPONSE misses non optional parameter of type lLRPStatus");
                throw new MissingParameterException(
                    "GET_READER_CONFIG_RESPONSE misses non optional parameter of type lLRPStatus");
            }

            root.removeChild("LLRPStatus", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("Identification", ns);

            if (temp != null) {
                identification = new Identification(temp);
                LOGGER.info(
                    "setting parameter identification for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type identification");
            }

            root.removeChild("Identification", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            antennaPropertiesList = new LinkedList<AntennaProperties>();
            tempList = root.getChildren("AntennaProperties", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type antennaPropertiesList");
            } else {
                for (Element e : tempList) {
                    antennaPropertiesList.add(new AntennaProperties(e));
                    LOGGER.debug(
                        "adding AntennaProperties to antennaPropertiesList ");
                }
            }

            root.removeChildren("AntennaProperties", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            antennaConfigurationList = new LinkedList<AntennaConfiguration>();
            tempList = root.getChildren("AntennaConfiguration", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type antennaConfigurationList");
            } else {
                for (Element e : tempList) {
                    antennaConfigurationList.add(new AntennaConfiguration(e));
                    LOGGER.debug(
                        "adding AntennaConfiguration to antennaConfigurationList ");
                }
            }

            root.removeChildren("AntennaConfiguration", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("ReaderEventNotificationSpec", ns);

            if (temp != null) {
                readerEventNotificationSpec = new ReaderEventNotificationSpec(temp);
                LOGGER.info(
                    "setting parameter readerEventNotificationSpec for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type readerEventNotificationSpec");
            }

            root.removeChild("ReaderEventNotificationSpec", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("ROReportSpec", ns);

            if (temp != null) {
                rOReportSpec = new ROReportSpec(temp);
                LOGGER.info(
                    "setting parameter rOReportSpec for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type rOReportSpec");
            }

            root.removeChild("ROReportSpec", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("AccessReportSpec", ns);

            if (temp != null) {
                accessReportSpec = new AccessReportSpec(temp);
                LOGGER.info(
                    "setting parameter accessReportSpec for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type accessReportSpec");
            }

            root.removeChild("AccessReportSpec", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("LLRPConfigurationStateValue", ns);

            if (temp != null) {
                lLRPConfigurationStateValue = new LLRPConfigurationStateValue(temp);
                LOGGER.info(
                    "setting parameter lLRPConfigurationStateValue for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type lLRPConfigurationStateValue");
            }

            root.removeChild("LLRPConfigurationStateValue", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("KeepaliveSpec", ns);

            if (temp != null) {
                keepaliveSpec = new KeepaliveSpec(temp);
                LOGGER.info(
                    "setting parameter keepaliveSpec for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type keepaliveSpec");
            }

            root.removeChild("KeepaliveSpec", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            gPIPortCurrentStateList = new LinkedList<GPIPortCurrentState>();
            tempList = root.getChildren("GPIPortCurrentState", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type gPIPortCurrentStateList");
            } else {
                for (Element e : tempList) {
                    gPIPortCurrentStateList.add(new GPIPortCurrentState(e));
                    LOGGER.debug(
                        "adding GPIPortCurrentState to gPIPortCurrentStateList ");
                }
            }

            root.removeChildren("GPIPortCurrentState", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            gPOWriteDataList = new LinkedList<GPOWriteData>();
            tempList = root.getChildren("GPOWriteData", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type gPOWriteDataList");
            } else {
                for (Element e : tempList) {
                    gPOWriteDataList.add(new GPOWriteData(e));
                    LOGGER.debug("adding GPOWriteData to gPOWriteDataList ");
                }
            }

            root.removeChildren("GPOWriteData", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("EventsAndReports", ns);

            if (temp != null) {
                eventsAndReports = new EventsAndReports(temp);
                LOGGER.info(
                    "setting parameter eventsAndReports for parameter GET_READER_CONFIG_RESPONSE");
            } else {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type eventsAndReports");
            }

            root.removeChild("EventsAndReports", ns);
            //parameter - not choices - no special actions needed
            //we expect a list of parameters
            customList = new LinkedList<Custom>();
            tempList = root.getChildren("Custom", ns);

            if ((tempList == null) || tempList.isEmpty()) {
                LOGGER.info(
                    "GET_READER_CONFIG_RESPONSE misses optional parameter of type customList");
            } else {
                for (Element e : tempList) {
                    customList.add(new Custom(e));
                    LOGGER.debug("adding Custom to customList ");
                }
            }

            root.removeChildren("Custom", ns);

            //custom parameter
            //end custom
            if (root.getChildren().size() > 0) {
                String message = "GET_READER_CONFIG_RESPONSE has unknown element " +
                    ((Element) root.getChildren().get(0)).getName();
                throw new InvalidLLRPMessageException(message);
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    //setters

    /**
    * set lLRPStatus of type LLRPStatus.
    * @param  lLRPStatus to be set
    */
    public void setLLRPStatus(final LLRPStatus lLRPStatus) {
        this.lLRPStatus = lLRPStatus;
    }

    /**
    * set identification of type Identification.
    * @param  identification to be set
    */
    public void setIdentification(final Identification identification) {
        this.identification = identification;
    }

    /**
    * set antennaPropertiesList of type  List &lt;AntennaProperties>.
    * @param  antennaPropertiesList to be set
    */
    public void setAntennaPropertiesList(
        final List<AntennaProperties> antennaPropertiesList) {
        this.antennaPropertiesList = antennaPropertiesList;
    }

    /**
    * set antennaConfigurationList of type  List &lt;AntennaConfiguration>.
    * @param  antennaConfigurationList to be set
    */
    public void setAntennaConfigurationList(
        final List<AntennaConfiguration> antennaConfigurationList) {
        this.antennaConfigurationList = antennaConfigurationList;
    }

    /**
    * set readerEventNotificationSpec of type ReaderEventNotificationSpec.
    * @param  readerEventNotificationSpec to be set
    */
    public void setReaderEventNotificationSpec(
        final ReaderEventNotificationSpec readerEventNotificationSpec) {
        this.readerEventNotificationSpec = readerEventNotificationSpec;
    }

    /**
    * set rOReportSpec of type ROReportSpec.
    * @param  rOReportSpec to be set
    */
    public void setROReportSpec(final ROReportSpec rOReportSpec) {
        this.rOReportSpec = rOReportSpec;
    }

    /**
    * set accessReportSpec of type AccessReportSpec.
    * @param  accessReportSpec to be set
    */
    public void setAccessReportSpec(final AccessReportSpec accessReportSpec) {
        this.accessReportSpec = accessReportSpec;
    }

    /**
    * set lLRPConfigurationStateValue of type LLRPConfigurationStateValue.
    * @param  lLRPConfigurationStateValue to be set
    */
    public void setLLRPConfigurationStateValue(
        final LLRPConfigurationStateValue lLRPConfigurationStateValue) {
        this.lLRPConfigurationStateValue = lLRPConfigurationStateValue;
    }

    /**
    * set keepaliveSpec of type KeepaliveSpec.
    * @param  keepaliveSpec to be set
    */
    public void setKeepaliveSpec(final KeepaliveSpec keepaliveSpec) {
        this.keepaliveSpec = keepaliveSpec;
    }

    /**
    * set gPIPortCurrentStateList of type  List &lt;GPIPortCurrentState>.
    * @param  gPIPortCurrentStateList to be set
    */
    public void setGPIPortCurrentStateList(
        final List<GPIPortCurrentState> gPIPortCurrentStateList) {
        this.gPIPortCurrentStateList = gPIPortCurrentStateList;
    }

    /**
    * set gPOWriteDataList of type  List &lt;GPOWriteData>.
    * @param  gPOWriteDataList to be set
    */
    public void setGPOWriteDataList(final List<GPOWriteData> gPOWriteDataList) {
        this.gPOWriteDataList = gPOWriteDataList;
    }

    /**
    * set eventsAndReports of type EventsAndReports.
    * @param  eventsAndReports to be set
    */
    public void setEventsAndReports(final EventsAndReports eventsAndReports) {
        this.eventsAndReports = eventsAndReports;
    }

    /**
    * set customList of type  List &lt;Custom>.
    * @param  customList to be set
    */
    public void setCustomList(final List<Custom> customList) {
        this.customList = customList;
    }

    // end setter

    //getters

    /**
    * get lLRPStatus of type LLRPStatus .
    * @return  LLRPStatus
    */
    public LLRPStatus getLLRPStatus() {
        return lLRPStatus;
    }

    /**
    * get identification of type Identification .
    * @return  Identification
    */
    public Identification getIdentification() {
        return identification;
    }

    /**
    * get antennaPropertiesList of type List &lt;AntennaProperties> .
    * @return  List &lt;AntennaProperties>
    */
    public List<AntennaProperties> getAntennaPropertiesList() {
        return antennaPropertiesList;
    }

    /**
    * get antennaConfigurationList of type List &lt;AntennaConfiguration> .
    * @return  List &lt;AntennaConfiguration>
    */
    public List<AntennaConfiguration> getAntennaConfigurationList() {
        return antennaConfigurationList;
    }

    /**
    * get readerEventNotificationSpec of type ReaderEventNotificationSpec .
    * @return  ReaderEventNotificationSpec
    */
    public ReaderEventNotificationSpec getReaderEventNotificationSpec() {
        return readerEventNotificationSpec;
    }

    /**
    * get rOReportSpec of type ROReportSpec .
    * @return  ROReportSpec
    */
    public ROReportSpec getROReportSpec() {
        return rOReportSpec;
    }

    /**
    * get accessReportSpec of type AccessReportSpec .
    * @return  AccessReportSpec
    */
    public AccessReportSpec getAccessReportSpec() {
        return accessReportSpec;
    }

    /**
    * get lLRPConfigurationStateValue of type LLRPConfigurationStateValue .
    * @return  LLRPConfigurationStateValue
    */
    public LLRPConfigurationStateValue getLLRPConfigurationStateValue() {
        return lLRPConfigurationStateValue;
    }

    /**
    * get keepaliveSpec of type KeepaliveSpec .
    * @return  KeepaliveSpec
    */
    public KeepaliveSpec getKeepaliveSpec() {
        return keepaliveSpec;
    }

    /**
    * get gPIPortCurrentStateList of type List &lt;GPIPortCurrentState> .
    * @return  List &lt;GPIPortCurrentState>
    */
    public List<GPIPortCurrentState> getGPIPortCurrentStateList() {
        return gPIPortCurrentStateList;
    }

    /**
    * get gPOWriteDataList of type List &lt;GPOWriteData> .
    * @return  List &lt;GPOWriteData>
    */
    public List<GPOWriteData> getGPOWriteDataList() {
        return gPOWriteDataList;
    }

    /**
    * get eventsAndReports of type EventsAndReports .
    * @return  EventsAndReports
    */
    public EventsAndReports getEventsAndReports() {
        return eventsAndReports;
    }

    /**
    * get customList of type List &lt;Custom> .
    * @return  List &lt;Custom>
    */
    public List<Custom> getCustomList() {
        return customList;
    }

    // end getters

    //add methods

    /**
    * add element antennaProperties of type AntennaProperties .
    * @param  antennaProperties of type AntennaProperties
    */
    public void addToAntennaPropertiesList(AntennaProperties antennaProperties) {
        if (this.antennaPropertiesList == null) {
            this.antennaPropertiesList = new LinkedList<AntennaProperties>();
        }

        this.antennaPropertiesList.add(antennaProperties);
    }

    /**
    * add element antennaConfiguration of type AntennaConfiguration .
    * @param  antennaConfiguration of type AntennaConfiguration
    */
    public void addToAntennaConfigurationList(
        AntennaConfiguration antennaConfiguration) {
        if (this.antennaConfigurationList == null) {
            this.antennaConfigurationList = new LinkedList<AntennaConfiguration>();
        }

        this.antennaConfigurationList.add(antennaConfiguration);
    }

    /**
    * add element gPIPortCurrentState of type GPIPortCurrentState .
    * @param  gPIPortCurrentState of type GPIPortCurrentState
    */
    public void addToGPIPortCurrentStateList(
        GPIPortCurrentState gPIPortCurrentState) {
        if (this.gPIPortCurrentStateList == null) {
            this.gPIPortCurrentStateList = new LinkedList<GPIPortCurrentState>();
        }

        this.gPIPortCurrentStateList.add(gPIPortCurrentState);
    }

    /**
    * add element gPOWriteData of type GPOWriteData .
    * @param  gPOWriteData of type GPOWriteData
    */
    public void addToGPOWriteDataList(GPOWriteData gPOWriteData) {
        if (this.gPOWriteDataList == null) {
            this.gPOWriteDataList = new LinkedList<GPOWriteData>();
        }

        this.gPOWriteDataList.add(gPOWriteData);
    }

    /**
    * add element custom of type Custom .
    * @param  custom of type Custom
    */
    public void addToCustomList(Custom custom) {
        if (this.customList == null) {
            this.customList = new LinkedList<Custom>();
        }

        this.customList.add(custom);
    }

    // end add
    @Override
    public String getResponseType() {
        return RESPONSETYPE;
    }

    @Override
    public String getName() {
        return "GET_READER_CONFIG_RESPONSE";
    }

    /**
    * return uniuque type number.
    * @return SignedShort holding unique type number
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }
}
