/*
*
* This file was generated by LLRP Code Generator
* see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
* for more information
* Generated on: Sun Apr 08 14:14:08 EDT 2012;
*
*/

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.messages;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.types.BitList;
import org.llrp.ltk.types.BytesToEnd_HEX;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.UnsignedByte;
import org.llrp.ltk.types.UnsignedInteger;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This message carries a vendor defined format from Reader to Client or Client to Reader. No requirements are made as to the content or parameters contained within the Data portion of these messages. Clients MAY ignore CUSTOM_MESSAGEs. Readers SHALL accept CUSTOM_MESSAGE and return an ERROR_MESSAGE if CUSTOM_MESSAGE is unsupported by the Reader or the CUSTOM_MESSAGE contains fields and/or parameters that are unsupported by the Reader.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=42&view=fit">LLRP Specification Section 8.1</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=129&view=fit">LLRP Specification Section 16.1.42</a>}


 */
public class CUSTOM_MESSAGE extends LLRPMessage {
    public static final SignedShort TYPENUM = new SignedShort(1023);
    private static final Logger LOGGER = Logger.getLogger(CUSTOM_MESSAGE.class);
    public static final String RESPONSETYPE = "";
    protected UnsignedInteger vendorIdentifier;
    protected UnsignedByte messageSubtype;
    protected BytesToEnd_HEX data;

    /**
     * empty constructor to create new message
     * with LLRP version set to 1.0 (0x1).
     */
    public CUSTOM_MESSAGE() {
        setVersion(new BitList(0, 0, 1));
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param list to be decoded
     */
    public CUSTOM_MESSAGE(final LLRPBitList list)
        throws InvalidLLRPMessageException {
        decodeBinary(list.toByteArray());
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param byteArray representing message
     */
    public CUSTOM_MESSAGE(final byte[] byteArray)
        throws InvalidLLRPMessageException {
        decodeBinary(byteArray);
    }

    /**
    * Constructor to create message from xml encoded message
    * calls decodeXML to decode message.
    * @param document to be decoded
    */
    public CUSTOM_MESSAGE(final Document document)
        throws InvalidLLRPMessageException {
        decodeXML(document);
    }

    /**
    * {@inheritDoc}
    */
    protected LLRPBitList encodeBinarySpecific()
        throws InvalidLLRPMessageException {
        LLRPBitList resultBits = new LLRPBitList();

        if (vendorIdentifier == null) {
            LOGGER.warn(" vendorIdentifier not set");
            throw new InvalidLLRPMessageException(
                " vendorIdentifier not set  for Parameter of Type CUSTOM_MESSAGE");
        }

        resultBits.append(vendorIdentifier.encodeBinary());

        if (messageSubtype == null) {
            LOGGER.warn(" messageSubtype not set");
            throw new InvalidLLRPMessageException(
                " messageSubtype not set  for Parameter of Type CUSTOM_MESSAGE");
        }

        resultBits.append(messageSubtype.encodeBinary());

        if (data == null) {
            LOGGER.warn(" data not set");
            throw new InvalidLLRPMessageException(
                " data not set  for Parameter of Type CUSTOM_MESSAGE");
        }

        resultBits.append(data.encodeBinary());

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Document encodeXML() throws InvalidLLRPMessageException {
        try {
            Namespace ns = Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE);

            Element root = new Element("CUSTOM_MESSAGE", ns);
            //	Element root = new Element("CUSTOM_MESSAGE");
            root.addNamespaceDeclaration(Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE));

            if (version == null) {
                throw new InvalidLLRPMessageException("Version not set");
            } else {
                root.setAttribute("Version", version.toInteger().toString());
            }

            if (messageID == null) {
                throw new InvalidLLRPMessageException("MessageID not set");
            } else {
                root.setAttribute("MessageID", messageID.toString(10));
            }

            if (vendorIdentifier == null) {
                LOGGER.warn(" vendorIdentifier not set");
                throw new MissingParameterException(" vendorIdentifier not set");
            } else {
                root.addContent(vendorIdentifier.encodeXML("VendorIdentifier",
                        ns));
            }

            if (messageSubtype == null) {
                LOGGER.warn(" messageSubtype not set");
                throw new MissingParameterException(" messageSubtype not set");
            } else {
                root.addContent(messageSubtype.encodeXML("MessageSubtype", ns));
            }

            if (data == null) {
                LOGGER.warn(" data not set");
                throw new MissingParameterException(" data not set");
            } else {
                root.addContent(data.encodeXML("Data", ns));
            }

            //parameters
            Document doc = new Document(root);

            if (isValidXMLMessage(doc, LLRPConstants.LLRPMESSAGESCHEMAPATH)) {
                return doc;
            } else {
                return null;
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary)
        throws InvalidLLRPMessageException {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;
        vendorIdentifier = new UnsignedInteger(binary.subList(position,
                    UnsignedInteger.length()));
        position += UnsignedInteger.length();
        messageSubtype = new UnsignedByte(binary.subList(position,
                    UnsignedByte.length()));
        position += UnsignedByte.length();
        data = new BytesToEnd_HEX(binary.subList(position,
                    binary.length() - position));
        position += (binary.length() - position);
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(final Document document)
        throws InvalidLLRPMessageException {
        Element temp = null;
        Custom custom;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        try {
            isValidXMLMessage(document, LLRPConstants.LLRPMESSAGESCHEMAPATH);

            Element root = (Element) document.getRootElement().clone();
            List<Element> tempList = null;

            // the version field is always 3 bit long 
            // if the version attribute is not set in the LTK-XML message,
            // it is set to version 001
            String versionAttribute = root.getAttributeValue("Version");

            if (versionAttribute != null) {
                version = new BitList(3);
                version.setValue(new Integer(versionAttribute));
            } else {
                version = new BitList(0, 0, 1);
            }

            messageID = new UnsignedInteger(root.getAttributeValue("MessageID"));
            temp = root.getChild("VendorIdentifier", root.getNamespace());

            //check if this element exist
            if (temp != null) {
                vendorIdentifier = new UnsignedInteger(temp);
            } else {
                LOGGER.warn(
                    "Element vendorIdentifier not provided in xml as child of " +
                    root.getName());
                throw new MissingParameterException(
                    "Element vendorIdentifier not provided");
            }

            root.removeChild("VendorIdentifier", root.getNamespace());
            temp = root.getChild("MessageSubtype", root.getNamespace());

            //check if this element exist
            if (temp != null) {
                messageSubtype = new UnsignedByte(temp);
            } else {
                LOGGER.warn(
                    "Element messageSubtype not provided in xml as child of " +
                    root.getName());
                throw new MissingParameterException(
                    "Element messageSubtype not provided");
            }

            root.removeChild("MessageSubtype", root.getNamespace());
            temp = root.getChild("Data", root.getNamespace());

            //check if this element exist
            if (temp != null) {
                data = new BytesToEnd_HEX(temp);
            } else {
                LOGGER.warn("Element data not provided in xml as child of " +
                    root.getName());
                throw new MissingParameterException("Element data not provided");
            }

            root.removeChild("Data", root.getNamespace());

            if (root.getChildren().size() > 0) {
                String message = "CUSTOM_MESSAGE has unknown element " +
                    ((Element) root.getChildren().get(0)).getName();
                throw new InvalidLLRPMessageException(message);
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    //setters
    /**
    * set   vendorIdentifier of type UnsignedInteger .
    * @param   vendorIdentifier to be set
    */
    public void setVendorIdentifier(final UnsignedInteger vendorIdentifier) {
        this.vendorIdentifier = vendorIdentifier;
    }

    /**
    * set   messageSubtype of type UnsignedByte .
    * @param   messageSubtype to be set
    */
    public void setMessageSubtype(final UnsignedByte messageSubtype) {
        this.messageSubtype = messageSubtype;
    }

    /**
    * set data of type BytesToEnd_HEX .
    * @param  data to be set
    */
    public void setData(final BytesToEnd_HEX data) {
        this.data = data;
    }

    // end setter

    //getters
    /**
    * get   vendorIdentifier of type UnsignedInteger.
    * @return   type UnsignedInteger to be set
    */
    public UnsignedInteger getVendorIdentifier() {
        return this.vendorIdentifier;
    }

    /**
    * get   messageSubtype of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMessageSubtype() {
        return this.messageSubtype;
    }

    /**
    * get data of type  BytesToEnd_HEX.
    * @return  BytesToEnd_HEX
    */
    public BytesToEnd_HEX getData() {
        return data;
    }

    // end getters

    //add methods

    // end add
    @Override
    public String getResponseType() {
        return RESPONSETYPE;
    }

    @Override
    public String getName() {
        return "CUSTOM_MESSAGE";
    }

    /**
    * return uniuque type number.
    * @return SignedShort holding unique type number
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }
}
