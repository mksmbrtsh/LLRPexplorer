/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: Sun Apr 08 14:14:11 EDT 2012;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Content;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.interfaces.AccessCommandOpSpecResult;
import org.llrp.ltk.generated.interfaces.AirProtocolTagData;
import org.llrp.ltk.generated.interfaces.EPCParameter;
import org.llrp.ltk.generated.parameters.AccessSpecID;
import org.llrp.ltk.generated.parameters.AntennaID;
import org.llrp.ltk.generated.parameters.C1G2BlockEraseOpSpecResult;
import org.llrp.ltk.generated.parameters.C1G2BlockWriteOpSpecResult;
import org.llrp.ltk.generated.parameters.C1G2KillOpSpecResult;
import org.llrp.ltk.generated.parameters.C1G2LockOpSpecResult;
import org.llrp.ltk.generated.parameters.C1G2ReadOpSpecResult;
import org.llrp.ltk.generated.parameters.C1G2WriteOpSpecResult;
import org.llrp.ltk.generated.parameters.C1G2_CRC;
import org.llrp.ltk.generated.parameters.C1G2_PC;
import org.llrp.ltk.generated.parameters.ChannelIndex;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.generated.parameters.EPCData;
import org.llrp.ltk.generated.parameters.EPC_96;
import org.llrp.ltk.generated.parameters.FirstSeenTimestampUTC;
import org.llrp.ltk.generated.parameters.FirstSeenTimestampUptime;
import org.llrp.ltk.generated.parameters.InventoryParameterSpecID;
import org.llrp.ltk.generated.parameters.LastSeenTimestampUTC;
import org.llrp.ltk.generated.parameters.LastSeenTimestampUptime;
import org.llrp.ltk.generated.parameters.PeakRSSI;
import org.llrp.ltk.generated.parameters.ROSpecID;
import org.llrp.ltk.generated.parameters.SpecIndex;
import org.llrp.ltk.generated.parameters.TagSeenCount;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This report parameter is generated per tag per accumulation scope. The only mandatory portion of this parameter is the EPCData parameter. If there was an access operation performed on the tag, the results of the OpSpecs are mandatory in the report. The other sub-parameters in this report are optional. LLRP provides three ways to make the tag reporting efficient:Allow parameters to be enabled or disabled via TagReportContentSelector (section 13.2.1.1) in TagReportSpec. If an optional parameter is enabled, and is absent in the report, the Client SHALL assume that the value is identical to the last parameter of the same type received. For example, this allows the Readers to not send a parameter in the report whose value has not changed since the last time it was sent by the Reader.Allow accumulation of tag reports. See next section for details of accumulation.
          A Reader MAY accumulate multiple tag reports into a single tag report.. If a Reader accumulates, the Reader SHALL follow the accumulation rules specified in this section. The following specifies the rules for accumulating multiple tag observations into a single TagReportData:EPCData:The Reader SHALL not accumulate tag reports that do not have the same EPCData value.OpSpecResultList:The Reader SHALL not accumulate tag reports that do not have the same value for the OpSpec results in the OpSpecResultList.SpecID, SpecIndex, InventoryParameterSpecID, AntennaID, AirProtocolTagData, AccessSpecID:These fields are optional, and their reporting can be enabled by the Client. If the Client has enabled one or more fields listed above, the Reader SHALL not accumulate tag reports that do not have the same value for all the enabled fields.FirstSeenTimestamp, LastSeenTimestamp, PeakRSSI, TagSeenCount, ChannelIndexThese fields are optional, and their reporting can be enabled by the Client. If the field is enabled, the Reader sets the value of these fields as follows:FirstSeenTimestamp: The Reader SHALL set it to the time of the first observation amongst the tag reports that get accumulated in the TagReportData.LastSeenTimestamp: The Reader SHALL set it to the time of the last observation amongst the tag reports that get accumulated in the TagReportData.PeakRSSI: The Reader SHALL set it to the maximum RSSI value observed amongst the tag reports that get accumulated in the TagReportData.ChannelIndex: The Reader MAY set it to the index of the first channel the tag was seen.TagSeenCount: The Reader SHALL set it to the number of tag reports that get accumulated in the TagReportData.




See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=80&view=fit">LLRP Specification Section 13.2.3</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=143&view=fit">LLRP Specification Section 16.2.7.3</a>}


 */

/**
 * This report parameter is generated per tag per accumulation scope. The only mandatory portion of this parameter is the EPCData parameter. If there was an access operation performed on the tag, the results of the OpSpecs are mandatory in the report. The other sub-parameters in this report are optional. LLRP provides three ways to make the tag reporting efficient:Allow parameters to be enabled or disabled via TagReportContentSelector (section 13.2.1.1) in TagReportSpec. If an optional parameter is enabled, and is absent in the report, the Client SHALL assume that the value is identical to the last parameter of the same type received. For example, this allows the Readers to not send a parameter in the report whose value has not changed since the last time it was sent by the Reader.Allow accumulation of tag reports. See next section for details of accumulation.
          A Reader MAY accumulate multiple tag reports into a single tag report.. If a Reader accumulates, the Reader SHALL follow the accumulation rules specified in this section. The following specifies the rules for accumulating multiple tag observations into a single TagReportData:EPCData:The Reader SHALL not accumulate tag reports that do not have the same EPCData value.OpSpecResultList:The Reader SHALL not accumulate tag reports that do not have the same value for the OpSpec results in the OpSpecResultList.SpecID, SpecIndex, InventoryParameterSpecID, AntennaID, AirProtocolTagData, AccessSpecID:These fields are optional, and their reporting can be enabled by the Client. If the Client has enabled one or more fields listed above, the Reader SHALL not accumulate tag reports that do not have the same value for all the enabled fields.FirstSeenTimestamp, LastSeenTimestamp, PeakRSSI, TagSeenCount, ChannelIndexThese fields are optional, and their reporting can be enabled by the Client. If the field is enabled, the Reader sets the value of these fields as follows:FirstSeenTimestamp: The Reader SHALL set it to the time of the first observation amongst the tag reports that get accumulated in the TagReportData.LastSeenTimestamp: The Reader SHALL set it to the time of the last observation amongst the tag reports that get accumulated in the TagReportData.PeakRSSI: The Reader SHALL set it to the maximum RSSI value observed amongst the tag reports that get accumulated in the TagReportData.ChannelIndex: The Reader MAY set it to the index of the first channel the tag was seen.TagSeenCount: The Reader SHALL set it to the number of tag reports that get accumulated in the TagReportData.




See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=80&view=fit">LLRP Specification Section 13.2.3</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=143&view=fit">LLRP Specification Section 16.2.7.3</a>}

      .
 */
public class TagReportData extends TLVParameter {
    public static final SignedShort TYPENUM = new SignedShort(240);
    private static final Logger LOGGER = Logger.getLogger(TagReportData.class);
    protected EPCParameter ePCParameter;
    protected ROSpecID rOSpecID;
    protected SpecIndex specIndex;
    protected InventoryParameterSpecID inventoryParameterSpecID;
    protected AntennaID antennaID;
    protected PeakRSSI peakRSSI;
    protected ChannelIndex channelIndex;
    protected FirstSeenTimestampUTC firstSeenTimestampUTC;
    protected FirstSeenTimestampUptime firstSeenTimestampUptime;
    protected LastSeenTimestampUTC lastSeenTimestampUTC;
    protected LastSeenTimestampUptime lastSeenTimestampUptime;
    protected TagSeenCount tagSeenCount;
    protected List<AirProtocolTagData> airProtocolTagDataList = new LinkedList<AirProtocolTagData>();
    protected AccessSpecID accessSpecID;
    protected List<AccessCommandOpSpecResult> accessCommandOpSpecResultList = new LinkedList<AccessCommandOpSpecResult>();
    protected List<Custom> customList = new LinkedList<Custom>();

    /**
     * empty constructor to create new parameter.
     */
    public TagReportData() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public TagReportData(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public TagReportData(Element element) throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (ePCParameter == null) {
            // single parameter, may not be null
            LOGGER.warn(" ePCParameter not set");
            throw new MissingParameterException(" ePCParameter not set");
        } else {
            resultBits.append(ePCParameter.encodeBinary());
        }

        if (rOSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" rOSpecID not set");
        } else {
            resultBits.append(rOSpecID.encodeBinary());
        }

        if (specIndex == null) {
            // optional parameter, may be null
            LOGGER.info(" specIndex not set");
        } else {
            resultBits.append(specIndex.encodeBinary());
        }

        if (inventoryParameterSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" inventoryParameterSpecID not set");
        } else {
            resultBits.append(inventoryParameterSpecID.encodeBinary());
        }

        if (antennaID == null) {
            // optional parameter, may be null
            LOGGER.info(" antennaID not set");
        } else {
            resultBits.append(antennaID.encodeBinary());
        }

        if (peakRSSI == null) {
            // optional parameter, may be null
            LOGGER.info(" peakRSSI not set");
        } else {
            resultBits.append(peakRSSI.encodeBinary());
        }

        if (channelIndex == null) {
            // optional parameter, may be null
            LOGGER.info(" channelIndex not set");
        } else {
            resultBits.append(channelIndex.encodeBinary());
        }

        if (firstSeenTimestampUTC == null) {
            // optional parameter, may be null
            LOGGER.info(" firstSeenTimestampUTC not set");
        } else {
            resultBits.append(firstSeenTimestampUTC.encodeBinary());
        }

        if (firstSeenTimestampUptime == null) {
            // optional parameter, may be null
            LOGGER.info(" firstSeenTimestampUptime not set");
        } else {
            resultBits.append(firstSeenTimestampUptime.encodeBinary());
        }

        if (lastSeenTimestampUTC == null) {
            // optional parameter, may be null
            LOGGER.info(" lastSeenTimestampUTC not set");
        } else {
            resultBits.append(lastSeenTimestampUTC.encodeBinary());
        }

        if (lastSeenTimestampUptime == null) {
            // optional parameter, may be null
            LOGGER.info(" lastSeenTimestampUptime not set");
        } else {
            resultBits.append(lastSeenTimestampUptime.encodeBinary());
        }

        if (tagSeenCount == null) {
            // optional parameter, may be null
            LOGGER.info(" tagSeenCount not set");
        } else {
            resultBits.append(tagSeenCount.encodeBinary());
        }

        if (airProtocolTagDataList == null) {
            //just warn - it is optional 
            LOGGER.info(" airProtocolTagDataList not set");
        } else {
            for (AirProtocolTagData field : airProtocolTagDataList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (accessSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" accessSpecID not set");
        } else {
            resultBits.append(accessSpecID.encodeBinary());
        }

        if (accessCommandOpSpecResultList == null) {
            //just warn - it is optional 
            LOGGER.info(" accessCommandOpSpecResultList not set");
        } else {
            for (AccessCommandOpSpecResult field : accessCommandOpSpecResultList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (customList == null) {
            //just warn - it is optional 
            LOGGER.info(" customList not set");
        } else {
            for (Custom field : customList) {
                resultBits.append(field.encodeBinary());
            }
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("llrp", LLRPConstants.LLRPNAMESPACE);

        //parameters
        if (ePCParameter == null) {
            LOGGER.info("ePCParameter not set");
            throw new MissingParameterException("ePCParameter not set");
        } else {
            element.addContent(ePCParameter.encodeXML(
                    ePCParameter.getClass().getSimpleName(), ns));
        }

        if (rOSpecID == null) {
            LOGGER.info("rOSpecID not set");
        } else {
            element.addContent(rOSpecID.encodeXML(rOSpecID.getClass()
                                                          .getSimpleName(), ns));
        }

        if (specIndex == null) {
            LOGGER.info("specIndex not set");
        } else {
            element.addContent(specIndex.encodeXML(specIndex.getClass()
                                                            .getSimpleName(), ns));
        }

        if (inventoryParameterSpecID == null) {
            LOGGER.info("inventoryParameterSpecID not set");
        } else {
            element.addContent(inventoryParameterSpecID.encodeXML(
                    inventoryParameterSpecID.getClass().getSimpleName(), ns));
        }

        if (antennaID == null) {
            LOGGER.info("antennaID not set");
        } else {
            element.addContent(antennaID.encodeXML(antennaID.getClass()
                                                            .getSimpleName(), ns));
        }

        if (peakRSSI == null) {
            LOGGER.info("peakRSSI not set");
        } else {
            element.addContent(peakRSSI.encodeXML(peakRSSI.getClass()
                                                          .getSimpleName(), ns));
        }

        if (channelIndex == null) {
            LOGGER.info("channelIndex not set");
        } else {
            element.addContent(channelIndex.encodeXML(
                    channelIndex.getClass().getSimpleName(), ns));
        }

        if (firstSeenTimestampUTC == null) {
            LOGGER.info("firstSeenTimestampUTC not set");
        } else {
            element.addContent(firstSeenTimestampUTC.encodeXML(
                    firstSeenTimestampUTC.getClass().getSimpleName(), ns));
        }

        if (firstSeenTimestampUptime == null) {
            LOGGER.info("firstSeenTimestampUptime not set");
        } else {
            element.addContent(firstSeenTimestampUptime.encodeXML(
                    firstSeenTimestampUptime.getClass().getSimpleName(), ns));
        }

        if (lastSeenTimestampUTC == null) {
            LOGGER.info("lastSeenTimestampUTC not set");
        } else {
            element.addContent(lastSeenTimestampUTC.encodeXML(
                    lastSeenTimestampUTC.getClass().getSimpleName(), ns));
        }

        if (lastSeenTimestampUptime == null) {
            LOGGER.info("lastSeenTimestampUptime not set");
        } else {
            element.addContent(lastSeenTimestampUptime.encodeXML(
                    lastSeenTimestampUptime.getClass().getSimpleName(), ns));
        }

        if (tagSeenCount == null) {
            LOGGER.info("tagSeenCount not set");
        } else {
            element.addContent(tagSeenCount.encodeXML(
                    tagSeenCount.getClass().getSimpleName(), ns));
        }

        if (airProtocolTagDataList == null) {
            LOGGER.info("airProtocolTagDataList not set");
        } else {
            for (AirProtocolTagData field : airProtocolTagDataList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        if (accessSpecID == null) {
            LOGGER.info("accessSpecID not set");
        } else {
            element.addContent(accessSpecID.encodeXML(
                    accessSpecID.getClass().getSimpleName(), ns));
        }

        if (accessCommandOpSpecResultList == null) {
            LOGGER.info("accessCommandOpSpecResultList not set");
        } else {
            for (AccessCommandOpSpecResult field : accessCommandOpSpecResultList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        if (customList == null) {
            LOGGER.info("customList not set");
        } else {
            for (Custom field : customList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.warn(
                "TagReportData misses non optional parameter of type EPCParameter");
            throw new MissingParameterException(
                "TagReportData misses non optional parameter of type EPCParameter");
        }

        boolean found = false;
        LOGGER.debug("decoding choice type EPCParameter ");

        //if first bit is 1 it is a TV Parameter
        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = EPCData.length();
        }

        if ((type != null) && type.equals(EPCData.TYPENUM)) {
            ePCParameter = new EPCData(binary.subList(position, tempLength));
            LOGGER.debug(" ePCParameter instatiated to EPCData with length " +
                tempLength);
            position += tempLength;
            found = true;
        }

        //if first bit is 1 it is a TV Parameter
        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = EPC_96.length();
        }

        if ((type != null) && type.equals(EPC_96.TYPENUM)) {
            ePCParameter = new EPC_96(binary.subList(position, tempLength));
            LOGGER.debug(" ePCParameter instatiated to EPC_96 with length " +
                tempLength);
            position += tempLength;
            found = true;
        }

        if (!found) {
            LOGGER.warn(
                "encoded message misses non optional parameter ePCParameter");
            throw new MissingParameterException(
                "TagReportData misses non optional parameter of type EPCParameter");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type ROSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = rOSpecID.length();
        }

        if ((type != null) && type.equals(ROSpecID.TYPENUM)) {
            rOSpecID = new ROSpecID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(" rOSpecID is instantiated with ROSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type ROSpecID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type SpecIndex");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = specIndex.length();
        }

        if ((type != null) && type.equals(SpecIndex.TYPENUM)) {
            specIndex = new SpecIndex(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " specIndex is instantiated with SpecIndex with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type SpecIndex");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type InventoryParameterSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = inventoryParameterSpecID.length();
        }

        if ((type != null) && type.equals(InventoryParameterSpecID.TYPENUM)) {
            inventoryParameterSpecID = new InventoryParameterSpecID(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " inventoryParameterSpecID is instantiated with InventoryParameterSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type InventoryParameterSpecID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type AntennaID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = antennaID.length();
        }

        if ((type != null) && type.equals(AntennaID.TYPENUM)) {
            antennaID = new AntennaID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " antennaID is instantiated with AntennaID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type AntennaID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type PeakRSSI");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = peakRSSI.length();
        }

        if ((type != null) && type.equals(PeakRSSI.TYPENUM)) {
            peakRSSI = new PeakRSSI(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(" peakRSSI is instantiated with PeakRSSI with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type PeakRSSI");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type ChannelIndex");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = channelIndex.length();
        }

        if ((type != null) && type.equals(ChannelIndex.TYPENUM)) {
            channelIndex = new ChannelIndex(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " channelIndex is instantiated with ChannelIndex with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type ChannelIndex");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type FirstSeenTimestampUTC");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = firstSeenTimestampUTC.length();
        }

        if ((type != null) && type.equals(FirstSeenTimestampUTC.TYPENUM)) {
            firstSeenTimestampUTC = new FirstSeenTimestampUTC(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " firstSeenTimestampUTC is instantiated with FirstSeenTimestampUTC with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type FirstSeenTimestampUTC");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type FirstSeenTimestampUptime");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = firstSeenTimestampUptime.length();
        }

        if ((type != null) && type.equals(FirstSeenTimestampUptime.TYPENUM)) {
            firstSeenTimestampUptime = new FirstSeenTimestampUptime(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " firstSeenTimestampUptime is instantiated with FirstSeenTimestampUptime with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type FirstSeenTimestampUptime");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type LastSeenTimestampUTC");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = lastSeenTimestampUTC.length();
        }

        if ((type != null) && type.equals(LastSeenTimestampUTC.TYPENUM)) {
            lastSeenTimestampUTC = new LastSeenTimestampUTC(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " lastSeenTimestampUTC is instantiated with LastSeenTimestampUTC with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type LastSeenTimestampUTC");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type LastSeenTimestampUptime");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = lastSeenTimestampUptime.length();
        }

        if ((type != null) && type.equals(LastSeenTimestampUptime.TYPENUM)) {
            lastSeenTimestampUptime = new LastSeenTimestampUptime(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " lastSeenTimestampUptime is instantiated with LastSeenTimestampUptime with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type LastSeenTimestampUptime");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type TagSeenCount");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = tagSeenCount.length();
        }

        if ((type != null) && type.equals(TagSeenCount.TYPENUM)) {
            tagSeenCount = new TagSeenCount(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " tagSeenCount is instantiated with TagSeenCount with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type TagSeenCount");
        }

        // list of parameters
        airProtocolTagDataList = new LinkedList<AirProtocolTagData>();
        LOGGER.debug("decoding parameter airProtocolTagDataList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //choiceRef
            if ((type != null) && type.equals(C1G2_PC.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2_PC.length();
                }

                airProtocolTagDataList.add(new C1G2_PC(binary.subList(
                            position, tempLength)));
                LOGGER.debug("adding C1G2_PC to airProtocolTagDataList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if ((type != null) && type.equals(C1G2_CRC.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2_CRC.length();
                }

                airProtocolTagDataList.add(new C1G2_CRC(binary.subList(
                            position, tempLength)));
                LOGGER.debug("adding C1G2_CRC to airProtocolTagDataList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (airProtocolTagDataList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional airProtocolTagDataList");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "TagReportData misses optional parameter of type AccessSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = accessSpecID.length();
        }

        if ((type != null) && type.equals(AccessSpecID.TYPENUM)) {
            accessSpecID = new AccessSpecID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " accessSpecID is instantiated with AccessSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "TagReportData misses optional parameter of type AccessSpecID");
        }

        // list of parameters
        accessCommandOpSpecResultList = new LinkedList<AccessCommandOpSpecResult>();
        LOGGER.debug("decoding parameter accessCommandOpSpecResultList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //choiceRef
            if ((type != null) && type.equals(C1G2ReadOpSpecResult.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2ReadOpSpecResult.length();
                }

                accessCommandOpSpecResultList.add(new C1G2ReadOpSpecResult(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding C1G2ReadOpSpecResult to accessCommandOpSpecResultList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if ((type != null) && type.equals(C1G2WriteOpSpecResult.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2WriteOpSpecResult.length();
                }

                accessCommandOpSpecResultList.add(new C1G2WriteOpSpecResult(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding C1G2WriteOpSpecResult to accessCommandOpSpecResultList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if ((type != null) && type.equals(C1G2KillOpSpecResult.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2KillOpSpecResult.length();
                }

                accessCommandOpSpecResultList.add(new C1G2KillOpSpecResult(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding C1G2KillOpSpecResult to accessCommandOpSpecResultList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if ((type != null) && type.equals(C1G2LockOpSpecResult.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2LockOpSpecResult.length();
                }

                accessCommandOpSpecResultList.add(new C1G2LockOpSpecResult(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding C1G2LockOpSpecResult to accessCommandOpSpecResultList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if ((type != null) &&
                    type.equals(C1G2BlockEraseOpSpecResult.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2BlockEraseOpSpecResult.length();
                }

                accessCommandOpSpecResultList.add(new C1G2BlockEraseOpSpecResult(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding C1G2BlockEraseOpSpecResult to accessCommandOpSpecResultList ");
                position += tempLength;
                atLeastOnce = true;
            }

            if ((type != null) &&
                    type.equals(C1G2BlockWriteOpSpecResult.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2BlockWriteOpSpecResult.length();
                }

                accessCommandOpSpecResultList.add(new C1G2BlockWriteOpSpecResult(
                        binary.subList(position, tempLength)));
                LOGGER.debug(
                    "adding C1G2BlockWriteOpSpecResult to accessCommandOpSpecResultList ");
                position += tempLength;
                atLeastOnce = true;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                // custom parameters for this parameter	
                //end  parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                accessCommandOpSpecResultList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (accessCommandOpSpecResultList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional accessCommandOpSpecResultList");
        }

        // list of parameters
        customList = new LinkedList<Custom>();
        LOGGER.debug("decoding parameter customList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                // custom parameters for this parameter	
                // TagReportData
                //end  parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                customList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (customList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional customList");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;
        Custom custom;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        //choices - must check all possible subtypes
        boolean found = false;
        LOGGER.debug("decoding choice type EPCParameter ");
        // try to get child for each possible subtype
        temp = element.getChild("EPCData", ns);

        if (temp != null) {
            ePCParameter = new EPCData(temp);
            LOGGER.debug(" ePCParameter instatiated to EPCData with");
            found = true;
        }

        element.removeChild("EPCData", ns);
        // try to get child for each possible subtype
        temp = element.getChild("EPC_96", ns);

        if (temp != null) {
            ePCParameter = new EPC_96(temp);
            LOGGER.debug(" ePCParameter instatiated to EPC_96 with");
            found = true;
        }

        element.removeChild("EPC_96", ns);

        if (!found) {
            LOGGER.info(
                "TagReportData misses optional parameter of type ePCParameterList");
        }

        //parameter - not choices - no special actions needed
        temp = element.getChild("ROSpecID", ns);

        if (temp != null) {
            rOSpecID = new ROSpecID(temp);
            LOGGER.info(
                "setting parameter rOSpecID for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type rOSpecID");
        }

        element.removeChild("ROSpecID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("SpecIndex", ns);

        if (temp != null) {
            specIndex = new SpecIndex(temp);
            LOGGER.info(
                "setting parameter specIndex for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type specIndex");
        }

        element.removeChild("SpecIndex", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("InventoryParameterSpecID", ns);

        if (temp != null) {
            inventoryParameterSpecID = new InventoryParameterSpecID(temp);
            LOGGER.info(
                "setting parameter inventoryParameterSpecID for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type inventoryParameterSpecID");
        }

        element.removeChild("InventoryParameterSpecID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("AntennaID", ns);

        if (temp != null) {
            antennaID = new AntennaID(temp);
            LOGGER.info(
                "setting parameter antennaID for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type antennaID");
        }

        element.removeChild("AntennaID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("PeakRSSI", ns);

        if (temp != null) {
            peakRSSI = new PeakRSSI(temp);
            LOGGER.info(
                "setting parameter peakRSSI for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type peakRSSI");
        }

        element.removeChild("PeakRSSI", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("ChannelIndex", ns);

        if (temp != null) {
            channelIndex = new ChannelIndex(temp);
            LOGGER.info(
                "setting parameter channelIndex for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type channelIndex");
        }

        element.removeChild("ChannelIndex", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("FirstSeenTimestampUTC", ns);

        if (temp != null) {
            firstSeenTimestampUTC = new FirstSeenTimestampUTC(temp);
            LOGGER.info(
                "setting parameter firstSeenTimestampUTC for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type firstSeenTimestampUTC");
        }

        element.removeChild("FirstSeenTimestampUTC", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("FirstSeenTimestampUptime", ns);

        if (temp != null) {
            firstSeenTimestampUptime = new FirstSeenTimestampUptime(temp);
            LOGGER.info(
                "setting parameter firstSeenTimestampUptime for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type firstSeenTimestampUptime");
        }

        element.removeChild("FirstSeenTimestampUptime", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("LastSeenTimestampUTC", ns);

        if (temp != null) {
            lastSeenTimestampUTC = new LastSeenTimestampUTC(temp);
            LOGGER.info(
                "setting parameter lastSeenTimestampUTC for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type lastSeenTimestampUTC");
        }

        element.removeChild("LastSeenTimestampUTC", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("LastSeenTimestampUptime", ns);

        if (temp != null) {
            lastSeenTimestampUptime = new LastSeenTimestampUptime(temp);
            LOGGER.info(
                "setting parameter lastSeenTimestampUptime for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type lastSeenTimestampUptime");
        }

        element.removeChild("LastSeenTimestampUptime", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("TagSeenCount", ns);

        if (temp != null) {
            tagSeenCount = new TagSeenCount(temp);
            LOGGER.info(
                "setting parameter tagSeenCount for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type tagSeenCount");
        }

        element.removeChild("TagSeenCount", ns);
        //choices - must check all possible subtypes
        //list of Choice Type Parameter
        airProtocolTagDataList = new LinkedList<AirProtocolTagData>();
        // for each possible subtype get all childs
        tempList = element.getChildren("C1G2_PC", ns);

        for (Element e : tempList) {
            airProtocolTagDataList.add(new C1G2_PC(e));
            LOGGER.debug("adding C1G2_PC to airProtocolTagDataList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2_PC", ns);

        tempList = element.getChildren("C1G2_CRC", ns);

        for (Element e : tempList) {
            airProtocolTagDataList.add(new C1G2_CRC(e));
            LOGGER.debug("adding C1G2_CRC to airProtocolTagDataList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2_CRC", ns);

        if (!atLeastOnce) {
            LOGGER.info(
                "TagReportData misses optional parameter of type airProtocolTagDataList");
        }

        atLeastOnce = false;
        //parameter - not choices - no special actions needed
        temp = element.getChild("AccessSpecID", ns);

        if (temp != null) {
            accessSpecID = new AccessSpecID(temp);
            LOGGER.info(
                "setting parameter accessSpecID for parameter TagReportData");
        }

        if (temp == null) {
            LOGGER.info(
                "TagReportData misses optional parameter of type accessSpecID");
        }

        element.removeChild("AccessSpecID", ns);
        //choices - must check all possible subtypes
        //list of Choice Type Parameter
        accessCommandOpSpecResultList = new LinkedList<AccessCommandOpSpecResult>();
        // for each possible subtype get all childs
        tempList = element.getChildren("C1G2ReadOpSpecResult", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new C1G2ReadOpSpecResult(e));
            LOGGER.debug(
                "adding C1G2ReadOpSpecResult to accessCommandOpSpecResultList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2ReadOpSpecResult", ns);

        tempList = element.getChildren("C1G2WriteOpSpecResult", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new C1G2WriteOpSpecResult(e));
            LOGGER.debug(
                "adding C1G2WriteOpSpecResult to accessCommandOpSpecResultList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2WriteOpSpecResult", ns);

        tempList = element.getChildren("C1G2KillOpSpecResult", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new C1G2KillOpSpecResult(e));
            LOGGER.debug(
                "adding C1G2KillOpSpecResult to accessCommandOpSpecResultList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2KillOpSpecResult", ns);

        tempList = element.getChildren("C1G2LockOpSpecResult", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new C1G2LockOpSpecResult(e));
            LOGGER.debug(
                "adding C1G2LockOpSpecResult to accessCommandOpSpecResultList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2LockOpSpecResult", ns);

        tempList = element.getChildren("C1G2BlockEraseOpSpecResult", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new C1G2BlockEraseOpSpecResult(e));
            LOGGER.debug(
                "adding C1G2BlockEraseOpSpecResult to accessCommandOpSpecResultList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2BlockEraseOpSpecResult", ns);

        tempList = element.getChildren("C1G2BlockWriteOpSpecResult", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new C1G2BlockWriteOpSpecResult(e));
            LOGGER.debug(
                "adding C1G2BlockWriteOpSpecResult to accessCommandOpSpecResultList ");
            atLeastOnce = true;
        }

        element.removeChildren("C1G2BlockWriteOpSpecResult", ns);

        // check for all custom parameters  for this parameter 
        // check for regular custom parameter
        tempList = element.getChildren("Custom", ns);

        for (Element e : tempList) {
            accessCommandOpSpecResultList.add(new Custom(e));
            LOGGER.debug(
                "adding AccessCommandOpSpecResult to accessCommandOpSpecResultList ");
        }

        element.removeChildren("Custom", ns);

        //end allowed parameters
        if (!atLeastOnce) {
            LOGGER.info(
                "TagReportData misses optional parameter of type accessCommandOpSpecResultList");
        }

        atLeastOnce = false;
        //parameter - not choices - no special actions needed
        //we expect a list of parameters
        customList = new LinkedList<Custom>();
        tempList = element.getChildren("Custom", ns);

        if ((tempList == null) || tempList.isEmpty()) {
            LOGGER.info(
                "TagReportData misses optional parameter of type customList");
        } else {
            for (Element e : tempList) {
                customList.add(new Custom(e));
                LOGGER.debug("adding Custom to customList ");
            }
        }

        element.removeChildren("Custom", ns);
        //custom parameter
        tempList = element.getChildren("Custom", ns);

        for (Element e : tempList) {
            customList.add(new Custom(e));
            atLeastOnce = true;
            LOGGER.debug("adding custom parameter");
        }

        element.removeChildren("Custom", ns);

        //end custom
        if (element.getChildren().size() > 0) {
            String message = "TagReportData has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters

    /**
    * set ePCParameter of type EPCParameter.
    * @param  ePCParameter to be set
    */
    public void setEPCParameter(final EPCParameter ePCParameter) {
        this.ePCParameter = ePCParameter;
    }

    /**
    * set rOSpecID of type ROSpecID.
    * @param  rOSpecID to be set
    */
    public void setROSpecID(final ROSpecID rOSpecID) {
        this.rOSpecID = rOSpecID;
    }

    /**
    * set specIndex of type SpecIndex.
    * @param  specIndex to be set
    */
    public void setSpecIndex(final SpecIndex specIndex) {
        this.specIndex = specIndex;
    }

    /**
    * set inventoryParameterSpecID of type InventoryParameterSpecID.
    * @param  inventoryParameterSpecID to be set
    */
    public void setInventoryParameterSpecID(
        final InventoryParameterSpecID inventoryParameterSpecID) {
        this.inventoryParameterSpecID = inventoryParameterSpecID;
    }

    /**
    * set antennaID of type AntennaID.
    * @param  antennaID to be set
    */
    public void setAntennaID(final AntennaID antennaID) {
        this.antennaID = antennaID;
    }

    /**
    * set peakRSSI of type PeakRSSI.
    * @param  peakRSSI to be set
    */
    public void setPeakRSSI(final PeakRSSI peakRSSI) {
        this.peakRSSI = peakRSSI;
    }

    /**
    * set channelIndex of type ChannelIndex.
    * @param  channelIndex to be set
    */
    public void setChannelIndex(final ChannelIndex channelIndex) {
        this.channelIndex = channelIndex;
    }

    /**
    * set firstSeenTimestampUTC of type FirstSeenTimestampUTC.
    * @param  firstSeenTimestampUTC to be set
    */
    public void setFirstSeenTimestampUTC(
        final FirstSeenTimestampUTC firstSeenTimestampUTC) {
        this.firstSeenTimestampUTC = firstSeenTimestampUTC;
    }

    /**
    * set firstSeenTimestampUptime of type FirstSeenTimestampUptime.
    * @param  firstSeenTimestampUptime to be set
    */
    public void setFirstSeenTimestampUptime(
        final FirstSeenTimestampUptime firstSeenTimestampUptime) {
        this.firstSeenTimestampUptime = firstSeenTimestampUptime;
    }

    /**
    * set lastSeenTimestampUTC of type LastSeenTimestampUTC.
    * @param  lastSeenTimestampUTC to be set
    */
    public void setLastSeenTimestampUTC(
        final LastSeenTimestampUTC lastSeenTimestampUTC) {
        this.lastSeenTimestampUTC = lastSeenTimestampUTC;
    }

    /**
    * set lastSeenTimestampUptime of type LastSeenTimestampUptime.
    * @param  lastSeenTimestampUptime to be set
    */
    public void setLastSeenTimestampUptime(
        final LastSeenTimestampUptime lastSeenTimestampUptime) {
        this.lastSeenTimestampUptime = lastSeenTimestampUptime;
    }

    /**
    * set tagSeenCount of type TagSeenCount.
    * @param  tagSeenCount to be set
    */
    public void setTagSeenCount(final TagSeenCount tagSeenCount) {
        this.tagSeenCount = tagSeenCount;
    }

    /**
    * set airProtocolTagDataList of type  List &lt;AirProtocolTagData>.
    * @param  airProtocolTagDataList to be set
    */
    public void setAirProtocolTagDataList(
        final List<AirProtocolTagData> airProtocolTagDataList) {
        this.airProtocolTagDataList = airProtocolTagDataList;
    }

    /**
    * set accessSpecID of type AccessSpecID.
    * @param  accessSpecID to be set
    */
    public void setAccessSpecID(final AccessSpecID accessSpecID) {
        this.accessSpecID = accessSpecID;
    }

    /**
    * set accessCommandOpSpecResultList of type  List &lt;AccessCommandOpSpecResult>.
    * @param  accessCommandOpSpecResultList to be set
    */
    public void setAccessCommandOpSpecResultList(
        final List<AccessCommandOpSpecResult> accessCommandOpSpecResultList) {
        this.accessCommandOpSpecResultList = accessCommandOpSpecResultList;
    }

    /**
    * set customList of type  List &lt;Custom>.
    * @param  customList to be set
    */
    public void setCustomList(final List<Custom> customList) {
        this.customList = customList;
    }

    // end setter

    //getters

    /**
    * get ePCParameter of type EPCParameter .
    * @return  EPCParameter
    */
    public EPCParameter getEPCParameter() {
        return ePCParameter;
    }

    /**
    * get rOSpecID of type ROSpecID .
    * @return  ROSpecID
    */
    public ROSpecID getROSpecID() {
        return rOSpecID;
    }

    /**
    * get specIndex of type SpecIndex .
    * @return  SpecIndex
    */
    public SpecIndex getSpecIndex() {
        return specIndex;
    }

    /**
    * get inventoryParameterSpecID of type InventoryParameterSpecID .
    * @return  InventoryParameterSpecID
    */
    public InventoryParameterSpecID getInventoryParameterSpecID() {
        return inventoryParameterSpecID;
    }

    /**
    * get antennaID of type AntennaID .
    * @return  AntennaID
    */
    public AntennaID getAntennaID() {
        return antennaID;
    }

    /**
    * get peakRSSI of type PeakRSSI .
    * @return  PeakRSSI
    */
    public PeakRSSI getPeakRSSI() {
        return peakRSSI;
    }

    /**
    * get channelIndex of type ChannelIndex .
    * @return  ChannelIndex
    */
    public ChannelIndex getChannelIndex() {
        return channelIndex;
    }

    /**
    * get firstSeenTimestampUTC of type FirstSeenTimestampUTC .
    * @return  FirstSeenTimestampUTC
    */
    public FirstSeenTimestampUTC getFirstSeenTimestampUTC() {
        return firstSeenTimestampUTC;
    }

    /**
    * get firstSeenTimestampUptime of type FirstSeenTimestampUptime .
    * @return  FirstSeenTimestampUptime
    */
    public FirstSeenTimestampUptime getFirstSeenTimestampUptime() {
        return firstSeenTimestampUptime;
    }

    /**
    * get lastSeenTimestampUTC of type LastSeenTimestampUTC .
    * @return  LastSeenTimestampUTC
    */
    public LastSeenTimestampUTC getLastSeenTimestampUTC() {
        return lastSeenTimestampUTC;
    }

    /**
    * get lastSeenTimestampUptime of type LastSeenTimestampUptime .
    * @return  LastSeenTimestampUptime
    */
    public LastSeenTimestampUptime getLastSeenTimestampUptime() {
        return lastSeenTimestampUptime;
    }

    /**
    * get tagSeenCount of type TagSeenCount .
    * @return  TagSeenCount
    */
    public TagSeenCount getTagSeenCount() {
        return tagSeenCount;
    }

    /**
    * get airProtocolTagDataList of type List &lt;AirProtocolTagData> .
    * @return  List &lt;AirProtocolTagData>
    */
    public List<AirProtocolTagData> getAirProtocolTagDataList() {
        return airProtocolTagDataList;
    }

    /**
    * get accessSpecID of type AccessSpecID .
    * @return  AccessSpecID
    */
    public AccessSpecID getAccessSpecID() {
        return accessSpecID;
    }

    /**
    * get accessCommandOpSpecResultList of type List &lt;AccessCommandOpSpecResult> .
    * @return  List &lt;AccessCommandOpSpecResult>
    */
    public List<AccessCommandOpSpecResult> getAccessCommandOpSpecResultList() {
        return accessCommandOpSpecResultList;
    }

    /**
    * get customList of type List &lt;Custom> .
    * @return  List &lt;Custom>
    */
    public List<Custom> getCustomList() {
        return customList;
    }

    // end getters

    //add methods

    /**
    * add element airProtocolTagData of type AirProtocolTagData .
    * @param  airProtocolTagData of type AirProtocolTagData
    */
    public void addToAirProtocolTagDataList(
        AirProtocolTagData airProtocolTagData) {
        if (this.airProtocolTagDataList == null) {
            this.airProtocolTagDataList = new LinkedList<AirProtocolTagData>();
        }

        this.airProtocolTagDataList.add(airProtocolTagData);
    }

    /**
    * add element accessCommandOpSpecResult of type AccessCommandOpSpecResult .
    * @param  accessCommandOpSpecResult of type AccessCommandOpSpecResult
    */
    public void addToAccessCommandOpSpecResultList(
        AccessCommandOpSpecResult accessCommandOpSpecResult) {
        if (this.accessCommandOpSpecResultList == null) {
            this.accessCommandOpSpecResultList = new LinkedList<AccessCommandOpSpecResult>();
        }

        this.accessCommandOpSpecResultList.add(accessCommandOpSpecResult);
    }

    /**
    * add element custom of type Custom .
    * @param  custom of type Custom
    */
    public void addToCustomList(Custom custom) {
        if (this.customList == null) {
            this.customList = new LinkedList<Custom>();
        }

        this.customList.add(custom);
    }

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "TagReportData";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "TagReportData: ";
        result = result.replaceFirst(", ", "");

        return result;
    }
}
