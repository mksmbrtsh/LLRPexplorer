/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: Sun Apr 08 14:14:11 EDT 2012;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Content;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UnsignedInteger;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This parameter, LLRPConfigurationStateValue, is a 32-bit value which represents a Reader's entire LLRP configuration state including: LLRP configuration parameters, vendor extension configuration parameters, ROSpecs, and AccessSpecs.  A Reader SHALL change this value only:Upon successful execution of any of the following messages: ADD_ROSPEC, DELETE_ROSPEC, ADD_ACCESSSPEC, DELETE_ACCESSSPEC, SET_READER_CONFIG, or any CUSTOM_MESSAGE command that alters the reader's internal configuration. Upon an automatically deleted AccessSpec due to completion of OperationCountValue number of operations (Section 11.2.1.1).
         A Reader SHALL not change this value when the CurrentState of a ROSpec or AccessSpec changes.The mechanism used to compute the LLRP configuration state value is implementation dependent.  However, a good implementation will insure that there's a high probability that the value will change when the Reader's configuration state changes.It is expected that a Client will configure the Reader and then request the Reader's configuration state value.  The Client will then save this state value. If this value does not change between two requests for it, then a Client may assume that the above components of the LLRP configuration have also not changed.When requested by a Client, the Reader SHALL compute a state value based upon the Reader's current configuration state.  Upon each request, the Reader SHALL return the same state value provided a Client has not altered the Reader's configuration state between requests.  Aside from this requirement, the computation of the state value is implementation dependent.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=71&view=fit">LLRP Specification Section 12.2.1</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=140&view=fit">LLRP Specification Section 16.2.6.1</a>}


 */

/**
 * This parameter, LLRPConfigurationStateValue, is a 32-bit value which represents a Reader's entire LLRP configuration state including: LLRP configuration parameters, vendor extension configuration parameters, ROSpecs, and AccessSpecs.  A Reader SHALL change this value only:Upon successful execution of any of the following messages: ADD_ROSPEC, DELETE_ROSPEC, ADD_ACCESSSPEC, DELETE_ACCESSSPEC, SET_READER_CONFIG, or any CUSTOM_MESSAGE command that alters the reader's internal configuration. Upon an automatically deleted AccessSpec due to completion of OperationCountValue number of operations (Section 11.2.1.1).
         A Reader SHALL not change this value when the CurrentState of a ROSpec or AccessSpec changes.The mechanism used to compute the LLRP configuration state value is implementation dependent.  However, a good implementation will insure that there's a high probability that the value will change when the Reader's configuration state changes.It is expected that a Client will configure the Reader and then request the Reader's configuration state value.  The Client will then save this state value. If this value does not change between two requests for it, then a Client may assume that the above components of the LLRP configuration have also not changed.When requested by a Client, the Reader SHALL compute a state value based upon the Reader's current configuration state.  Upon each request, the Reader SHALL return the same state value provided a Client has not altered the Reader's configuration state between requests.  Aside from this requirement, the computation of the state value is implementation dependent.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=71&view=fit">LLRP Specification Section 12.2.1</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=140&view=fit">LLRP Specification Section 16.2.6.1</a>}

      .
 */
public class LLRPConfigurationStateValue extends TLVParameter {
    public static final SignedShort TYPENUM = new SignedShort(217);
    private static final Logger LOGGER = Logger.getLogger(LLRPConfigurationStateValue.class);
    protected UnsignedInteger lLRPConfigurationStateValue;

    /**
     * empty constructor to create new parameter.
     */
    public LLRPConfigurationStateValue() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public LLRPConfigurationStateValue(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public LLRPConfigurationStateValue(Element element)
        throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (lLRPConfigurationStateValue == null) {
            LOGGER.warn(" lLRPConfigurationStateValue not set");
            throw new MissingParameterException(
                " lLRPConfigurationStateValue not set  for Parameter of Type LLRPConfigurationStateValue");
        }

        resultBits.append(lLRPConfigurationStateValue.encodeBinary());

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("llrp", LLRPConstants.LLRPNAMESPACE);

        if (lLRPConfigurationStateValue == null) {
            LOGGER.warn(" lLRPConfigurationStateValue not set");
            throw new MissingParameterException(
                " lLRPConfigurationStateValue not set");
        } else {
            element.addContent(lLRPConfigurationStateValue.encodeXML(
                    "LLRPConfigurationStateValue", ns));
        }

        //parameters
        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;
        lLRPConfigurationStateValue = new UnsignedInteger(binary.subList(
                    position, UnsignedInteger.length()));
        position += UnsignedInteger.length();
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;
        Custom custom;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        temp = element.getChild("LLRPConfigurationStateValue", ns);

        if (temp != null) {
            lLRPConfigurationStateValue = new UnsignedInteger(temp);
        }

        element.removeChild("LLRPConfigurationStateValue", ns);

        if (element.getChildren().size() > 0) {
            String message = "LLRPConfigurationStateValue has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters
    /**
    * set   lLRPConfigurationStateValue of type UnsignedInteger .
    * @param   lLRPConfigurationStateValue to be set
    */
    public void setLLRPConfigurationStateValue(
        final UnsignedInteger lLRPConfigurationStateValue) {
        this.lLRPConfigurationStateValue = lLRPConfigurationStateValue;
    }

    // end setter

    //getters
    /**
    * get   lLRPConfigurationStateValue of type UnsignedInteger.
    * @return   type UnsignedInteger to be set
    */
    public UnsignedInteger getLLRPConfigurationStateValue() {
        return this.lLRPConfigurationStateValue;
    }

    // end getters

    //add methods

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "LLRPConfigurationStateValue";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "LLRPConfigurationStateValue: ";
        result += ", lLRPConfigurationStateValue: ";
        result += lLRPConfigurationStateValue;
        result = result.replaceFirst(", ", "");

        return result;
    }
}
