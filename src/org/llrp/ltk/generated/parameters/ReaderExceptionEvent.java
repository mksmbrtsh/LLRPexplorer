/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: Sun Apr 08 14:14:11 EDT 2012;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Content;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.parameters.AccessSpecID;
import org.llrp.ltk.generated.parameters.AntennaID;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.generated.parameters.InventoryParameterSpecID;
import org.llrp.ltk.generated.parameters.OpSpecID;
import org.llrp.ltk.generated.parameters.ROSpecID;
import org.llrp.ltk.generated.parameters.SpecIndex;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UTF8String_UTF_8;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * The reader exception status event notifies the client that an unexpected event has occurred on the reader.  Optional parameters provide more detail to the client as to the nature and scope of the event.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=90&view=fit">LLRP Specification Section 13.2.6.7</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=149&view=fit">LLRP Specification Section 16.2.7.6.6</a>}


 */

/**
 * The reader exception status event notifies the client that an unexpected event has occurred on the reader.  Optional parameters provide more detail to the client as to the nature and scope of the event.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=90&view=fit">LLRP Specification Section 13.2.6.7</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=149&view=fit">LLRP Specification Section 16.2.7.6.6</a>}

      .
 */
public class ReaderExceptionEvent extends TLVParameter {
    public static final SignedShort TYPENUM = new SignedShort(252);
    private static final Logger LOGGER = Logger.getLogger(ReaderExceptionEvent.class);
    protected UTF8String_UTF_8 message;
    protected ROSpecID rOSpecID;
    protected SpecIndex specIndex;
    protected InventoryParameterSpecID inventoryParameterSpecID;
    protected AntennaID antennaID;
    protected AccessSpecID accessSpecID;
    protected OpSpecID opSpecID;
    protected List<Custom> customList = new LinkedList<Custom>();

    /**
     * empty constructor to create new parameter.
     */
    public ReaderExceptionEvent() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public ReaderExceptionEvent(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public ReaderExceptionEvent(Element element)
        throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (message == null) {
            LOGGER.warn(" message not set");
            throw new MissingParameterException(
                " message not set  for Parameter of Type ReaderExceptionEvent");
        }

        resultBits.append(message.encodeBinary());

        if (rOSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" rOSpecID not set");
        } else {
            resultBits.append(rOSpecID.encodeBinary());
        }

        if (specIndex == null) {
            // optional parameter, may be null
            LOGGER.info(" specIndex not set");
        } else {
            resultBits.append(specIndex.encodeBinary());
        }

        if (inventoryParameterSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" inventoryParameterSpecID not set");
        } else {
            resultBits.append(inventoryParameterSpecID.encodeBinary());
        }

        if (antennaID == null) {
            // optional parameter, may be null
            LOGGER.info(" antennaID not set");
        } else {
            resultBits.append(antennaID.encodeBinary());
        }

        if (accessSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" accessSpecID not set");
        } else {
            resultBits.append(accessSpecID.encodeBinary());
        }

        if (opSpecID == null) {
            // optional parameter, may be null
            LOGGER.info(" opSpecID not set");
        } else {
            resultBits.append(opSpecID.encodeBinary());
        }

        if (customList == null) {
            //just warn - it is optional 
            LOGGER.info(" customList not set");
        } else {
            for (Custom field : customList) {
                resultBits.append(field.encodeBinary());
            }
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("llrp", LLRPConstants.LLRPNAMESPACE);

        if (message == null) {
            LOGGER.warn(" message not set");
            throw new MissingParameterException(" message not set");
        } else {
            element.addContent(message.encodeXML("Message", ns));
        }

        //parameters
        if (rOSpecID == null) {
            LOGGER.info("rOSpecID not set");
        } else {
            element.addContent(rOSpecID.encodeXML(rOSpecID.getClass()
                                                          .getSimpleName(), ns));
        }

        if (specIndex == null) {
            LOGGER.info("specIndex not set");
        } else {
            element.addContent(specIndex.encodeXML(specIndex.getClass()
                                                            .getSimpleName(), ns));
        }

        if (inventoryParameterSpecID == null) {
            LOGGER.info("inventoryParameterSpecID not set");
        } else {
            element.addContent(inventoryParameterSpecID.encodeXML(
                    inventoryParameterSpecID.getClass().getSimpleName(), ns));
        }

        if (antennaID == null) {
            LOGGER.info("antennaID not set");
        } else {
            element.addContent(antennaID.encodeXML(antennaID.getClass()
                                                            .getSimpleName(), ns));
        }

        if (accessSpecID == null) {
            LOGGER.info("accessSpecID not set");
        } else {
            element.addContent(accessSpecID.encodeXML(
                    accessSpecID.getClass().getSimpleName(), ns));
        }

        if (opSpecID == null) {
            LOGGER.info("opSpecID not set");
        } else {
            element.addContent(opSpecID.encodeXML(opSpecID.getClass()
                                                          .getSimpleName(), ns));
        }

        if (customList == null) {
            LOGGER.info("customList not set");
        } else {
            for (Custom field : customList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;
        // array. first 16 bits indicate length of array
        fieldCount = new UnsignedShort(binary.subList(position,
                    UnsignedShort.length())).toShort();
        tempLength = (UTF8String_UTF_8.length() * fieldCount) +
            UnsignedShort.length();
        message = new UTF8String_UTF_8(binary.subList(position, tempLength));
        position += tempLength;
        LOGGER.debug("decoding array of type: UTF8String_UTF_8 with " +
            tempLength + " length");

        //might need padding
        // must always be blocks of 8 bites, if it is a bitlist, this might not be automatically the case
        if ((tempLength % 8) > 0) {
            position += (8 - (tempLength % 8));
            LOGGER.info("padding needed for message ");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type ROSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = rOSpecID.length();
        }

        if ((type != null) && type.equals(ROSpecID.TYPENUM)) {
            rOSpecID = new ROSpecID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(" rOSpecID is instantiated with ROSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type ROSpecID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type SpecIndex");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = specIndex.length();
        }

        if ((type != null) && type.equals(SpecIndex.TYPENUM)) {
            specIndex = new SpecIndex(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " specIndex is instantiated with SpecIndex with length" +
                tempLength);
        } else {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type SpecIndex");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type InventoryParameterSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = inventoryParameterSpecID.length();
        }

        if ((type != null) && type.equals(InventoryParameterSpecID.TYPENUM)) {
            inventoryParameterSpecID = new InventoryParameterSpecID(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " inventoryParameterSpecID is instantiated with InventoryParameterSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type InventoryParameterSpecID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type AntennaID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = antennaID.length();
        }

        if ((type != null) && type.equals(AntennaID.TYPENUM)) {
            antennaID = new AntennaID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " antennaID is instantiated with AntennaID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type AntennaID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type AccessSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = accessSpecID.length();
        }

        if ((type != null) && type.equals(AccessSpecID.TYPENUM)) {
            accessSpecID = new AccessSpecID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " accessSpecID is instantiated with AccessSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type AccessSpecID");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type OpSpecID");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = opSpecID.length();
        }

        if ((type != null) && type.equals(OpSpecID.TYPENUM)) {
            opSpecID = new OpSpecID(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(" opSpecID is instantiated with OpSpecID with length" +
                tempLength);
        } else {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type OpSpecID");
        }

        // list of parameters
        customList = new LinkedList<Custom>();
        LOGGER.debug("decoding parameter customList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                // custom parameters for this parameter	
                // ReaderExceptionEvent
                //end  parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                customList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (customList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional customList");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;
        Custom custom;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        temp = element.getChild("Message", ns);

        if (temp != null) {
            message = new UTF8String_UTF_8(temp);
        }

        element.removeChild("Message", ns);

        //parameter - not choices - no special actions needed
        temp = element.getChild("ROSpecID", ns);

        if (temp != null) {
            rOSpecID = new ROSpecID(temp);
            LOGGER.info(
                "setting parameter rOSpecID for parameter ReaderExceptionEvent");
        }

        if (temp == null) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type rOSpecID");
        }

        element.removeChild("ROSpecID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("SpecIndex", ns);

        if (temp != null) {
            specIndex = new SpecIndex(temp);
            LOGGER.info(
                "setting parameter specIndex for parameter ReaderExceptionEvent");
        }

        if (temp == null) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type specIndex");
        }

        element.removeChild("SpecIndex", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("InventoryParameterSpecID", ns);

        if (temp != null) {
            inventoryParameterSpecID = new InventoryParameterSpecID(temp);
            LOGGER.info(
                "setting parameter inventoryParameterSpecID for parameter ReaderExceptionEvent");
        }

        if (temp == null) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type inventoryParameterSpecID");
        }

        element.removeChild("InventoryParameterSpecID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("AntennaID", ns);

        if (temp != null) {
            antennaID = new AntennaID(temp);
            LOGGER.info(
                "setting parameter antennaID for parameter ReaderExceptionEvent");
        }

        if (temp == null) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type antennaID");
        }

        element.removeChild("AntennaID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("AccessSpecID", ns);

        if (temp != null) {
            accessSpecID = new AccessSpecID(temp);
            LOGGER.info(
                "setting parameter accessSpecID for parameter ReaderExceptionEvent");
        }

        if (temp == null) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type accessSpecID");
        }

        element.removeChild("AccessSpecID", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("OpSpecID", ns);

        if (temp != null) {
            opSpecID = new OpSpecID(temp);
            LOGGER.info(
                "setting parameter opSpecID for parameter ReaderExceptionEvent");
        }

        if (temp == null) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type opSpecID");
        }

        element.removeChild("OpSpecID", ns);
        //parameter - not choices - no special actions needed
        //we expect a list of parameters
        customList = new LinkedList<Custom>();
        tempList = element.getChildren("Custom", ns);

        if ((tempList == null) || tempList.isEmpty()) {
            LOGGER.info(
                "ReaderExceptionEvent misses optional parameter of type customList");
        } else {
            for (Element e : tempList) {
                customList.add(new Custom(e));
                LOGGER.debug("adding Custom to customList ");
            }
        }

        element.removeChildren("Custom", ns);
        //custom parameter
        tempList = element.getChildren("Custom", ns);

        for (Element e : tempList) {
            customList.add(new Custom(e));
            atLeastOnce = true;
            LOGGER.debug("adding custom parameter");
        }

        element.removeChildren("Custom", ns);

        //end custom
        if (element.getChildren().size() > 0) {
            String message = "ReaderExceptionEvent has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters
    /**
    * set message of type UTF8String_UTF_8 .
    * @param  message to be set
    */
    public void setMessage(final UTF8String_UTF_8 message) {
        this.message = message;
    }

    /**
    * set rOSpecID of type ROSpecID.
    * @param  rOSpecID to be set
    */
    public void setROSpecID(final ROSpecID rOSpecID) {
        this.rOSpecID = rOSpecID;
    }

    /**
    * set specIndex of type SpecIndex.
    * @param  specIndex to be set
    */
    public void setSpecIndex(final SpecIndex specIndex) {
        this.specIndex = specIndex;
    }

    /**
    * set inventoryParameterSpecID of type InventoryParameterSpecID.
    * @param  inventoryParameterSpecID to be set
    */
    public void setInventoryParameterSpecID(
        final InventoryParameterSpecID inventoryParameterSpecID) {
        this.inventoryParameterSpecID = inventoryParameterSpecID;
    }

    /**
    * set antennaID of type AntennaID.
    * @param  antennaID to be set
    */
    public void setAntennaID(final AntennaID antennaID) {
        this.antennaID = antennaID;
    }

    /**
    * set accessSpecID of type AccessSpecID.
    * @param  accessSpecID to be set
    */
    public void setAccessSpecID(final AccessSpecID accessSpecID) {
        this.accessSpecID = accessSpecID;
    }

    /**
    * set opSpecID of type OpSpecID.
    * @param  opSpecID to be set
    */
    public void setOpSpecID(final OpSpecID opSpecID) {
        this.opSpecID = opSpecID;
    }

    /**
    * set customList of type  List &lt;Custom>.
    * @param  customList to be set
    */
    public void setCustomList(final List<Custom> customList) {
        this.customList = customList;
    }

    // end setter

    //getters
    /**
    * get message of type  UTF8String_UTF_8.
    * @return  UTF8String_UTF_8
    */
    public UTF8String_UTF_8 getMessage() {
        return message;
    }

    /**
    * get rOSpecID of type ROSpecID .
    * @return  ROSpecID
    */
    public ROSpecID getROSpecID() {
        return rOSpecID;
    }

    /**
    * get specIndex of type SpecIndex .
    * @return  SpecIndex
    */
    public SpecIndex getSpecIndex() {
        return specIndex;
    }

    /**
    * get inventoryParameterSpecID of type InventoryParameterSpecID .
    * @return  InventoryParameterSpecID
    */
    public InventoryParameterSpecID getInventoryParameterSpecID() {
        return inventoryParameterSpecID;
    }

    /**
    * get antennaID of type AntennaID .
    * @return  AntennaID
    */
    public AntennaID getAntennaID() {
        return antennaID;
    }

    /**
    * get accessSpecID of type AccessSpecID .
    * @return  AccessSpecID
    */
    public AccessSpecID getAccessSpecID() {
        return accessSpecID;
    }

    /**
    * get opSpecID of type OpSpecID .
    * @return  OpSpecID
    */
    public OpSpecID getOpSpecID() {
        return opSpecID;
    }

    /**
    * get customList of type List &lt;Custom> .
    * @return  List &lt;Custom>
    */
    public List<Custom> getCustomList() {
        return customList;
    }

    // end getters

    //add methods

    /**
    * add element custom of type Custom .
    * @param  custom of type Custom
    */
    public void addToCustomList(Custom custom) {
        if (this.customList == null) {
            this.customList = new LinkedList<Custom>();
        }

        this.customList.add(custom);
    }

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "ReaderExceptionEvent";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "ReaderExceptionEvent: ";
        result += ", message: ";
        result += message;
        result = result.replaceFirst(", ", "");

        return result;
    }
}
