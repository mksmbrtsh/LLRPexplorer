/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: Sun Apr 08 14:14:11 EDT 2012;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Content;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.enumerations.IdentificationType;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UnsignedByteArray_HEX;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This parameter carries an identification parameter that is unique within the local administration domain.  The identifier could be the Reader MAC address or EPC. The IDType defines the type of the identification value contained in this Parameter.If IDType=0, the MAC address SHALL be encoded as  EUI-64.[EUI64]

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=72&view=fit">LLRP Specification Section 12.2.2</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=140&view=fit">LLRP Specification Section 16.2.6.2</a>}


 */

/**
 * This parameter carries an identification parameter that is unique within the local administration domain.  The identifier could be the Reader MAC address or EPC. The IDType defines the type of the identification value contained in this Parameter.If IDType=0, the MAC address SHALL be encoded as  EUI-64.[EUI64]

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=72&view=fit">LLRP Specification Section 12.2.2</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=140&view=fit">LLRP Specification Section 16.2.6.2</a>}

      .
 */
public class Identification extends TLVParameter {
    public static final SignedShort TYPENUM = new SignedShort(218);
    private static final Logger LOGGER = Logger.getLogger(Identification.class);
    protected IdentificationType iDType;
    protected UnsignedByteArray_HEX readerID;

    /**
     * empty constructor to create new parameter.
     */
    public Identification() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public Identification(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public Identification(Element element) throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (iDType == null) {
            LOGGER.warn(" iDType not set");
            throw new MissingParameterException(
                " iDType not set  for Parameter of Type Identification");
        }

        resultBits.append(iDType.encodeBinary());

        if (readerID == null) {
            LOGGER.warn(" readerID not set");
            throw new MissingParameterException(
                " readerID not set  for Parameter of Type Identification");
        }

        resultBits.append(readerID.encodeBinary());

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("llrp", LLRPConstants.LLRPNAMESPACE);

        if (iDType == null) {
            LOGGER.warn(" iDType not set");
            throw new MissingParameterException(" iDType not set");
        } else {
            element.addContent(iDType.encodeXML("IDType", ns));
        }

        if (readerID == null) {
            LOGGER.warn(" readerID not set");
            throw new MissingParameterException(" readerID not set");
        } else {
            element.addContent(readerID.encodeXML("ReaderID", ns));
        }

        //parameters
        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;
        iDType = new IdentificationType(binary.subList(position,
                    IdentificationType.length()));
        position += IdentificationType.length();
        // array. first 16 bits indicate length of array
        fieldCount = new UnsignedShort(binary.subList(position,
                    UnsignedShort.length())).toShort();
        tempLength = (UnsignedByteArray_HEX.length() * fieldCount) +
            UnsignedShort.length();
        readerID = new UnsignedByteArray_HEX(binary.subList(position, tempLength));
        position += tempLength;
        LOGGER.debug("decoding array of type: UnsignedByteArray_HEX with " +
            tempLength + " length");

        //might need padding
        // must always be blocks of 8 bites, if it is a bitlist, this might not be automatically the case
        if ((tempLength % 8) > 0) {
            position += (8 - (tempLength % 8));
            LOGGER.info("padding needed for readerID ");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;
        Custom custom;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        temp = element.getChild("IDType", ns);

        if (temp != null) {
            iDType = new IdentificationType(temp);
        }

        element.removeChild("IDType", ns);
        temp = element.getChild("ReaderID", ns);

        if (temp != null) {
            readerID = new UnsignedByteArray_HEX(temp);
        }

        element.removeChild("ReaderID", ns);

        if (element.getChildren().size() > 0) {
            String message = "Identification has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters
    /**
    * set iDType of type IdentificationType .
    * @param  iDType to be set
    */
    public void setIDType(final IdentificationType iDType) {
        this.iDType = iDType;
    }

    /**
    * set readerID of type UnsignedByteArray_HEX .
    * @param  readerID to be set
    */
    public void setReaderID(final UnsignedByteArray_HEX readerID) {
        this.readerID = readerID;
    }

    // end setter

    //getters
    /**
    * get iDType of type IdentificationType.
    * @return  IdentificationType
    */
    public IdentificationType getIDType() {
        return iDType;
    }

    /**
    * get readerID of type  UnsignedByteArray_HEX.
    * @return  UnsignedByteArray_HEX
    */
    public UnsignedByteArray_HEX getReaderID() {
        return readerID;
    }

    // end getters

    //add methods

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "Identification";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "Identification: ";
        result += ", iDType: ";
        result += iDType;
        result += ", readerID: ";
        result += readerID;
        result = result.replaceFirst(", ", "");

        return result;
    }
}
