/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: Sun Apr 08 14:14:11 EDT 2012;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Content;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.interfaces.SpecParameter;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.generated.parameters.RFSurveySpecStopTrigger;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UnsignedInteger;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This parameter defines RF Survey operations. RF Survey is an operation during which the Reader performs a scan and measures the power levels across a set of frequencies at an antenna. This parameter defines the identifier of the antenna where this survey is to be performed, the duration of the survey operation (specified via stop trigger), and the range of frequencies to measure power levels of.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=59&view=fit">LLRP Specification Section 10.2.3</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=138&view=fit">LLRP Specification Section 16.2.4.3</a>}


 */

/**
 * This parameter defines RF Survey operations. RF Survey is an operation during which the Reader performs a scan and measures the power levels across a set of frequencies at an antenna. This parameter defines the identifier of the antenna where this survey is to be performed, the duration of the survey operation (specified via stop trigger), and the range of frequencies to measure power levels of.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=59&view=fit">LLRP Specification Section 10.2.3</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=138&view=fit">LLRP Specification Section 16.2.4.3</a>}

      .
 */
public class RFSurveySpec extends TLVParameter implements SpecParameter {
    public static final SignedShort TYPENUM = new SignedShort(187);
    private static final Logger LOGGER = Logger.getLogger(RFSurveySpec.class);
    protected UnsignedShort antennaID;
    protected UnsignedInteger startFrequency;
    protected UnsignedInteger endFrequency;
    protected RFSurveySpecStopTrigger rFSurveySpecStopTrigger;
    protected List<Custom> customList = new LinkedList<Custom>();

    /**
     * empty constructor to create new parameter.
     */
    public RFSurveySpec() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public RFSurveySpec(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public RFSurveySpec(Element element) throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (antennaID == null) {
            LOGGER.warn(" antennaID not set");
            throw new MissingParameterException(
                " antennaID not set  for Parameter of Type RFSurveySpec");
        }

        resultBits.append(antennaID.encodeBinary());

        if (startFrequency == null) {
            LOGGER.warn(" startFrequency not set");
            throw new MissingParameterException(
                " startFrequency not set  for Parameter of Type RFSurveySpec");
        }

        resultBits.append(startFrequency.encodeBinary());

        if (endFrequency == null) {
            LOGGER.warn(" endFrequency not set");
            throw new MissingParameterException(
                " endFrequency not set  for Parameter of Type RFSurveySpec");
        }

        resultBits.append(endFrequency.encodeBinary());

        if (rFSurveySpecStopTrigger == null) {
            // single parameter, may not be null
            LOGGER.warn(" rFSurveySpecStopTrigger not set");
            throw new MissingParameterException(
                " rFSurveySpecStopTrigger not set");
        } else {
            resultBits.append(rFSurveySpecStopTrigger.encodeBinary());
        }

        if (customList == null) {
            //just warn - it is optional 
            LOGGER.info(" customList not set");
        } else {
            for (Custom field : customList) {
                resultBits.append(field.encodeBinary());
            }
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("llrp", LLRPConstants.LLRPNAMESPACE);

        if (antennaID == null) {
            LOGGER.warn(" antennaID not set");
            throw new MissingParameterException(" antennaID not set");
        } else {
            element.addContent(antennaID.encodeXML("AntennaID", ns));
        }

        if (startFrequency == null) {
            LOGGER.warn(" startFrequency not set");
            throw new MissingParameterException(" startFrequency not set");
        } else {
            element.addContent(startFrequency.encodeXML("StartFrequency", ns));
        }

        if (endFrequency == null) {
            LOGGER.warn(" endFrequency not set");
            throw new MissingParameterException(" endFrequency not set");
        } else {
            element.addContent(endFrequency.encodeXML("EndFrequency", ns));
        }

        //parameters
        if (rFSurveySpecStopTrigger == null) {
            LOGGER.info("rFSurveySpecStopTrigger not set");
            throw new MissingParameterException(
                "rFSurveySpecStopTrigger not set");
        } else {
            element.addContent(rFSurveySpecStopTrigger.encodeXML(
                    rFSurveySpecStopTrigger.getClass().getSimpleName(), ns));
        }

        if (customList == null) {
            LOGGER.info("customList not set");
        } else {
            for (Custom field : customList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;
        antennaID = new UnsignedShort(binary.subList(position,
                    UnsignedShort.length()));
        position += UnsignedShort.length();
        startFrequency = new UnsignedInteger(binary.subList(position,
                    UnsignedInteger.length()));
        position += UnsignedInteger.length();
        endFrequency = new UnsignedInteger(binary.subList(position,
                    UnsignedInteger.length()));
        position += UnsignedInteger.length();

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.warn(
                "RFSurveySpec misses non optional parameter of type RFSurveySpecStopTrigger");
            throw new MissingParameterException(
                "RFSurveySpec misses non optional parameter of type RFSurveySpecStopTrigger");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = rFSurveySpecStopTrigger.length();
        }

        if ((type != null) && type.equals(RFSurveySpecStopTrigger.TYPENUM)) {
            rFSurveySpecStopTrigger = new RFSurveySpecStopTrigger(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " rFSurveySpecStopTrigger is instantiated with RFSurveySpecStopTrigger with length" +
                tempLength);
        } else {
            LOGGER.warn(
                "RFSurveySpec misses non optional parameter of type RFSurveySpecStopTrigger");
            throw new MissingParameterException(
                "RFSurveySpec misses non optional parameter of type RFSurveySpecStopTrigger");
        }

        // list of parameters
        customList = new LinkedList<Custom>();
        LOGGER.debug("decoding parameter customList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                // custom parameters for this parameter	
                // RFSurveySpec
                //end  parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                customList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (customList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional customList");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;
        Custom custom;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        temp = element.getChild("AntennaID", ns);

        if (temp != null) {
            antennaID = new UnsignedShort(temp);
        }

        element.removeChild("AntennaID", ns);
        temp = element.getChild("StartFrequency", ns);

        if (temp != null) {
            startFrequency = new UnsignedInteger(temp);
        }

        element.removeChild("StartFrequency", ns);
        temp = element.getChild("EndFrequency", ns);

        if (temp != null) {
            endFrequency = new UnsignedInteger(temp);
        }

        element.removeChild("EndFrequency", ns);

        //parameter - not choices - no special actions needed
        temp = element.getChild("RFSurveySpecStopTrigger", ns);

        if (temp != null) {
            rFSurveySpecStopTrigger = new RFSurveySpecStopTrigger(temp);
            LOGGER.info(
                "setting parameter rFSurveySpecStopTrigger for parameter RFSurveySpec");
        }

        if (temp == null) {
            LOGGER.warn(
                "RFSurveySpec misses non optional parameter of type rFSurveySpecStopTrigger");
            throw new MissingParameterException(
                "RFSurveySpec misses non optional parameter of type rFSurveySpecStopTrigger");
        }

        element.removeChild("RFSurveySpecStopTrigger", ns);
        //parameter - not choices - no special actions needed
        //we expect a list of parameters
        customList = new LinkedList<Custom>();
        tempList = element.getChildren("Custom", ns);

        if ((tempList == null) || tempList.isEmpty()) {
            LOGGER.info(
                "RFSurveySpec misses optional parameter of type customList");
        } else {
            for (Element e : tempList) {
                customList.add(new Custom(e));
                LOGGER.debug("adding Custom to customList ");
            }
        }

        element.removeChildren("Custom", ns);
        //custom parameter
        tempList = element.getChildren("Custom", ns);

        for (Element e : tempList) {
            customList.add(new Custom(e));
            atLeastOnce = true;
            LOGGER.debug("adding custom parameter");
        }

        element.removeChildren("Custom", ns);

        //end custom
        if (element.getChildren().size() > 0) {
            String message = "RFSurveySpec has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters
    /**
    * set   antennaID of type UnsignedShort .
    * @param   antennaID to be set
    */
    public void setAntennaID(final UnsignedShort antennaID) {
        this.antennaID = antennaID;
    }

    /**
    * set   startFrequency of type UnsignedInteger .
    * @param   startFrequency to be set
    */
    public void setStartFrequency(final UnsignedInteger startFrequency) {
        this.startFrequency = startFrequency;
    }

    /**
    * set   endFrequency of type UnsignedInteger .
    * @param   endFrequency to be set
    */
    public void setEndFrequency(final UnsignedInteger endFrequency) {
        this.endFrequency = endFrequency;
    }

    /**
    * set rFSurveySpecStopTrigger of type RFSurveySpecStopTrigger.
    * @param  rFSurveySpecStopTrigger to be set
    */
    public void setRFSurveySpecStopTrigger(
        final RFSurveySpecStopTrigger rFSurveySpecStopTrigger) {
        this.rFSurveySpecStopTrigger = rFSurveySpecStopTrigger;
    }

    /**
    * set customList of type  List &lt;Custom>.
    * @param  customList to be set
    */
    public void setCustomList(final List<Custom> customList) {
        this.customList = customList;
    }

    // end setter

    //getters
    /**
    * get   antennaID of type UnsignedShort.
    * @return   type UnsignedShort to be set
    */
    public UnsignedShort getAntennaID() {
        return this.antennaID;
    }

    /**
    * get   startFrequency of type UnsignedInteger.
    * @return   type UnsignedInteger to be set
    */
    public UnsignedInteger getStartFrequency() {
        return this.startFrequency;
    }

    /**
    * get   endFrequency of type UnsignedInteger.
    * @return   type UnsignedInteger to be set
    */
    public UnsignedInteger getEndFrequency() {
        return this.endFrequency;
    }

    /**
    * get rFSurveySpecStopTrigger of type RFSurveySpecStopTrigger .
    * @return  RFSurveySpecStopTrigger
    */
    public RFSurveySpecStopTrigger getRFSurveySpecStopTrigger() {
        return rFSurveySpecStopTrigger;
    }

    /**
    * get customList of type List &lt;Custom> .
    * @return  List &lt;Custom>
    */
    public List<Custom> getCustomList() {
        return customList;
    }

    // end getters

    //add methods

    /**
    * add element custom of type Custom .
    * @param  custom of type Custom
    */
    public void addToCustomList(Custom custom) {
        if (this.customList == null) {
            this.customList = new LinkedList<Custom>();
        }

        this.customList.add(custom);
    }

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "RFSurveySpec";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "RFSurveySpec: ";
        result += ", antennaID: ";
        result += antennaID;
        result += ", startFrequency: ";
        result += startFrequency;
        result += ", endFrequency: ";
        result += endFrequency;
        result = result.replaceFirst(", ", "");

        return result;
    }
}
