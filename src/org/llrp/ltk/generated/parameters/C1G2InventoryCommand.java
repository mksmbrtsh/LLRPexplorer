/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: Sun Apr 08 14:14:12 EDT 2012;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import maximsblog.blogspot.com.llrpexplorer.Logger;

import org.jdom2.Content;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.interfaces.AirProtocolInventoryCommandSettings;
import org.llrp.ltk.generated.parameters.C1G2Filter;
import org.llrp.ltk.generated.parameters.C1G2RFControl;
import org.llrp.ltk.generated.parameters.C1G2SingulationControl;
import org.llrp.ltk.generated.parameters.Custom;
import org.llrp.ltk.types.Bit;
import org.llrp.ltk.types.BitList;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 * This parameter defines the C1G2 inventory-specific settings to be used during a particular C1G2 inventory operation. This comprises of C1G2Filter Parameter, C1G2RF Parameter and C1G2Singulation Parameter. It is not necessary that the Filter, RF Control and Singulation Control Parameters be specified in each and every inventory command. They are optional parameters. If not specified, the default values in the Reader are used during the inventory operation. If multiple C1G2Filter parameters are encapsulated by the Client in the C1G2InventoryCommand parameter, the ordering of the filter parameters determine the order of C1G2 air-protocol commands (e.g., Select command) generated by the Reader.The TagInventoryStateAware flag is used to determine how to process all the C1G2Filter and C1G2Singulation parameters in this command. At a functional level, if the Client is managing the tag states during an inventory operation, it would set that flag to true and pass the appropriate fields in the C1G2 Filter and C1G2 Singulation parameters. If a reader set CanDoTagInventoryStateAwareSingulation to False in LLRPCapabilities (section 9.2.2), it SHALL ignore the TagInventoryStateAware flag.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=100&view=fit">LLRP Specification Section 15.2.1.2.1</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=154&view=fit">LLRP Specification Section 16.3.1.2.1</a>}


 */

/**
 * This parameter defines the C1G2 inventory-specific settings to be used during a particular C1G2 inventory operation. This comprises of C1G2Filter Parameter, C1G2RF Parameter and C1G2Singulation Parameter. It is not necessary that the Filter, RF Control and Singulation Control Parameters be specified in each and every inventory command. They are optional parameters. If not specified, the default values in the Reader are used during the inventory operation. If multiple C1G2Filter parameters are encapsulated by the Client in the C1G2InventoryCommand parameter, the ordering of the filter parameters determine the order of C1G2 air-protocol commands (e.g., Select command) generated by the Reader.The TagInventoryStateAware flag is used to determine how to process all the C1G2Filter and C1G2Singulation parameters in this command. At a functional level, if the Client is managing the tag states during an inventory operation, it would set that flag to true and pass the appropriate fields in the C1G2 Filter and C1G2 Singulation parameters. If a reader set CanDoTagInventoryStateAwareSingulation to False in LLRPCapabilities (section 9.2.2), it SHALL ignore the TagInventoryStateAware flag.

See also {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=100&view=fit">LLRP Specification Section 15.2.1.2.1</a>}
 and {@link <a href="http://www.epcglobalinc.org/standards/llrp/llrp_1_0_1-standard-20070813.pdf#page=154&view=fit">LLRP Specification Section 16.3.1.2.1</a>}

      .
 */
public class C1G2InventoryCommand extends TLVParameter
    implements AirProtocolInventoryCommandSettings {
    public static final SignedShort TYPENUM = new SignedShort(330);
    private static final Logger LOGGER = Logger.getLogger(C1G2InventoryCommand.class);
    protected Bit tagInventoryStateAware;
    protected BitList reserved0 = new BitList(7);
    protected List<C1G2Filter> c1G2FilterList = new LinkedList<C1G2Filter>();
    protected C1G2RFControl c1G2RFControl;
    protected C1G2SingulationControl c1G2SingulationControl;
    protected List<Custom> customList = new LinkedList<Custom>();

    /**
     * empty constructor to create new parameter.
     */
    public C1G2InventoryCommand() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public C1G2InventoryCommand(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public C1G2InventoryCommand(Element element)
        throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (tagInventoryStateAware == null) {
            LOGGER.warn(" tagInventoryStateAware not set");
            throw new MissingParameterException(
                " tagInventoryStateAware not set  for Parameter of Type C1G2InventoryCommand");
        }

        resultBits.append(tagInventoryStateAware.encodeBinary());
        resultBits.append(reserved0.encodeBinary());

        if (c1G2FilterList == null) {
            //just warn - it is optional 
            LOGGER.info(" c1G2FilterList not set");
        } else {
            for (C1G2Filter field : c1G2FilterList) {
                resultBits.append(field.encodeBinary());
            }
        }

        if (c1G2RFControl == null) {
            // optional parameter, may be null
            LOGGER.info(" c1G2RFControl not set");
        } else {
            resultBits.append(c1G2RFControl.encodeBinary());
        }

        if (c1G2SingulationControl == null) {
            // optional parameter, may be null
            LOGGER.info(" c1G2SingulationControl not set");
        } else {
            resultBits.append(c1G2SingulationControl.encodeBinary());
        }

        if (customList == null) {
            //just warn - it is optional 
            LOGGER.info(" customList not set");
        } else {
            for (Custom field : customList) {
                resultBits.append(field.encodeBinary());
            }
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("llrp", LLRPConstants.LLRPNAMESPACE);

        if (tagInventoryStateAware == null) {
            LOGGER.warn(" tagInventoryStateAware not set");
            throw new MissingParameterException(
                " tagInventoryStateAware not set");
        } else {
            element.addContent(tagInventoryStateAware.encodeXML(
                    "TagInventoryStateAware", ns));
        }

        //element.addContent(reserved0.encodeXML("reserved",ns));
        //parameters
        if (c1G2FilterList == null) {
            LOGGER.info("c1G2FilterList not set");
        } else {
            for (C1G2Filter field : c1G2FilterList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        if (c1G2RFControl == null) {
            LOGGER.info("c1G2RFControl not set");
        } else {
            element.addContent(c1G2RFControl.encodeXML(
                    c1G2RFControl.getClass().getSimpleName(), ns));
        }

        if (c1G2SingulationControl == null) {
            LOGGER.info("c1G2SingulationControl not set");
        } else {
            element.addContent(c1G2SingulationControl.encodeXML(
                    c1G2SingulationControl.getClass().getSimpleName(), ns));
        }

        if (customList == null) {
            LOGGER.info("customList not set");
        } else {
            for (Custom field : customList) {
                element.addContent(field.encodeXML(field.getClass().getName()
                                                        .replaceAll(field.getClass()
                                                                         .getPackage()
                                                                         .getName() +
                            ".", ""), ns));
            }
        }

        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        Custom custom;
        tagInventoryStateAware = new Bit(binary.subList(position, Bit.length()));
        position += Bit.length();
        position += reserved0.length();

        // list of parameters
        c1G2FilterList = new LinkedList<C1G2Filter>();
        LOGGER.debug("decoding parameter c1G2FilterList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            //add parameter to list if type number matches
            if ((type != null) && type.equals(C1G2Filter.TYPENUM)) {
                if (binary.get(position)) {
                    // length can statically be determined for TV Parameters
                    tempLength = C1G2Filter.length();
                }

                c1G2FilterList.add(new C1G2Filter(binary.subList(position,
                            tempLength)));
                LOGGER.debug("adding C1G2Filter to c1G2FilterList ");
                atLeastOnce = true;
                position += tempLength;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (c1G2FilterList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional c1G2FilterList");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type C1G2RFControl");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = c1G2RFControl.length();
        }

        if ((type != null) && type.equals(C1G2RFControl.TYPENUM)) {
            c1G2RFControl = new C1G2RFControl(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " c1G2RFControl is instantiated with C1G2RFControl with length" +
                tempLength);
        } else {
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type C1G2RFControl");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type C1G2SingulationControl");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = c1G2SingulationControl.length();
        }

        if ((type != null) && type.equals(C1G2SingulationControl.TYPENUM)) {
            c1G2SingulationControl = new C1G2SingulationControl(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " c1G2SingulationControl is instantiated with C1G2SingulationControl with length" +
                tempLength);
        } else {
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type C1G2SingulationControl");
        }

        // list of parameters
        customList = new LinkedList<Custom>();
        LOGGER.debug("decoding parameter customList ");

        while (position < binary.length()) {
            // store if one parameter matched
            boolean atLeastOnce = false;

            // look ahead to see type
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                type = new SignedShort(binary.subList(position +
                            RESERVEDLENGTH, TYPENUMBERLENGTH));
                tempByteLength = new UnsignedShort(binary.subList(position +
                            RESERVEDLENGTH + TYPENUMBERLENGTH,
                            UnsignedShort.length())).toShort();
                tempLength = 8 * tempByteLength;
            }

            // custom
            if ((type != null) && type.equals(Custom.TYPENUM)) {
                Custom cus = new Custom(binary.subList(position, tempLength));
                // custom parameters for this parameter	
                // C1G2InventoryCommand
                //end  parameters
                //if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
                customList.add(cus);
                position += tempLength;
                atLeastOnce = true;
            }

            if (!atLeastOnce) {
                //no parameter matched therefore we jump out of the loop
                break;
            }
        }

        //if list is still empty no parameter matched
        if (customList.isEmpty()) {
            LOGGER.info(
                "encoded message does not contain parameter for optional customList");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;
        Custom custom;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        temp = element.getChild("TagInventoryStateAware", ns);

        if (temp != null) {
            tagInventoryStateAware = new Bit(temp);
        }

        element.removeChild("TagInventoryStateAware", ns);

        //parameter - not choices - no special actions needed
        //we expect a list of parameters
        c1G2FilterList = new LinkedList<C1G2Filter>();
        tempList = element.getChildren("C1G2Filter", ns);

        if ((tempList == null) || tempList.isEmpty()) {
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type c1G2FilterList");
        } else {
            for (Element e : tempList) {
                c1G2FilterList.add(new C1G2Filter(e));
                LOGGER.debug("adding C1G2Filter to c1G2FilterList ");
            }
        }

        element.removeChildren("C1G2Filter", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("C1G2RFControl", ns);

        if (temp != null) {
            c1G2RFControl = new C1G2RFControl(temp);
            LOGGER.info(
                "setting parameter c1G2RFControl for parameter C1G2InventoryCommand");
        }

        if (temp == null) {
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type c1G2RFControl");
        }

        element.removeChild("C1G2RFControl", ns);
        //parameter - not choices - no special actions needed
        temp = element.getChild("C1G2SingulationControl", ns);

        if (temp != null) {
            c1G2SingulationControl = new C1G2SingulationControl(temp);
            LOGGER.info(
                "setting parameter c1G2SingulationControl for parameter C1G2InventoryCommand");
        }

        if (temp == null) {
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type c1G2SingulationControl");
        }

        element.removeChild("C1G2SingulationControl", ns);
        //parameter - not choices - no special actions needed
        //we expect a list of parameters
        customList = new LinkedList<Custom>();
        tempList = element.getChildren("Custom", ns);

        if ((tempList == null) || tempList.isEmpty()) {
            LOGGER.info(
                "C1G2InventoryCommand misses optional parameter of type customList");
        } else {
            for (Element e : tempList) {
                customList.add(new Custom(e));
                LOGGER.debug("adding Custom to customList ");
            }
        }

        element.removeChildren("Custom", ns);
        //custom parameter
        tempList = element.getChildren("Custom", ns);

        for (Element e : tempList) {
            customList.add(new Custom(e));
            atLeastOnce = true;
            LOGGER.debug("adding custom parameter");
        }

        element.removeChildren("Custom", ns);

        //end custom
        if (element.getChildren().size() > 0) {
            String message = "C1G2InventoryCommand has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters
    /**
    * set   tagInventoryStateAware of type Bit .
    * @param   tagInventoryStateAware to be set
    */
    public void setTagInventoryStateAware(final Bit tagInventoryStateAware) {
        this.tagInventoryStateAware = tagInventoryStateAware;
    }

    /**
    * set c1G2FilterList of type  List &lt;C1G2Filter>.
    * @param  c1G2FilterList to be set
    */
    public void setC1G2FilterList(final List<C1G2Filter> c1G2FilterList) {
        this.c1G2FilterList = c1G2FilterList;
    }

    /**
    * set c1G2RFControl of type C1G2RFControl.
    * @param  c1G2RFControl to be set
    */
    public void setC1G2RFControl(final C1G2RFControl c1G2RFControl) {
        this.c1G2RFControl = c1G2RFControl;
    }

    /**
    * set c1G2SingulationControl of type C1G2SingulationControl.
    * @param  c1G2SingulationControl to be set
    */
    public void setC1G2SingulationControl(
        final C1G2SingulationControl c1G2SingulationControl) {
        this.c1G2SingulationControl = c1G2SingulationControl;
    }

    /**
    * set customList of type  List &lt;Custom>.
    * @param  customList to be set
    */
    public void setCustomList(final List<Custom> customList) {
        this.customList = customList;
    }

    // end setter

    //getters
    /**
    * get   tagInventoryStateAware of type Bit.
    * @return   type Bit to be set
    */
    public Bit getTagInventoryStateAware() {
        return this.tagInventoryStateAware;
    }

    /**
    * get c1G2FilterList of type List &lt;C1G2Filter> .
    * @return  List &lt;C1G2Filter>
    */
    public List<C1G2Filter> getC1G2FilterList() {
        return c1G2FilterList;
    }

    /**
    * get c1G2RFControl of type C1G2RFControl .
    * @return  C1G2RFControl
    */
    public C1G2RFControl getC1G2RFControl() {
        return c1G2RFControl;
    }

    /**
    * get c1G2SingulationControl of type C1G2SingulationControl .
    * @return  C1G2SingulationControl
    */
    public C1G2SingulationControl getC1G2SingulationControl() {
        return c1G2SingulationControl;
    }

    /**
    * get customList of type List &lt;Custom> .
    * @return  List &lt;Custom>
    */
    public List<Custom> getCustomList() {
        return customList;
    }

    // end getters

    //add methods

    /**
    * add element c1G2Filter of type C1G2Filter .
    * @param  c1G2Filter of type C1G2Filter
    */
    public void addToC1G2FilterList(C1G2Filter c1G2Filter) {
        if (this.c1G2FilterList == null) {
            this.c1G2FilterList = new LinkedList<C1G2Filter>();
        }

        this.c1G2FilterList.add(c1G2Filter);
    }

    /**
    * add element custom of type Custom .
    * @param  custom of type Custom
    */
    public void addToCustomList(Custom custom) {
        if (this.customList == null) {
            this.customList = new LinkedList<Custom>();
        }

        this.customList.add(custom);
    }

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "C1G2InventoryCommand";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "C1G2InventoryCommand: ";
        result += ", tagInventoryStateAware: ";
        result += tagInventoryStateAware;

        result = result.replaceFirst(", ", "");

        return result;
    }
}
